{"version":3,"file":"server.bundle.js","sources":["webpack:///webpack/bootstrap","webpack:///(webpack)/hot/log-apply-result.js","webpack:///(webpack)/hot/log.js","webpack:///(webpack)/hot/poll.js","webpack:///./server/controllers/auth.controller.js","webpack:///./server/controllers/user.controller.js","webpack:///./server/controllers/userValidator.js","webpack:///./server/db.js","webpack:///./server/index.js","webpack:///./server/mailer.js","webpack:///./server/middleware.js","webpack:///./server/models/emailVerifyToken.model.js","webpack:///./server/models/index.js","webpack:///./server/models/message.model.js","webpack:///./server/models/room.model.js","webpack:///./server/models/user.model.js","webpack:///./server/passport.js","webpack:///./server/routes/auth.router.js","webpack:///./server/routes/index.js","webpack:///./server/routes/user.router.js","webpack:///./server/server.js","webpack:///./server/socketEvent.js","webpack:///./server/utils/helpers.js","webpack:///./server/utils/message.js","webpack:///./server/utils/users.js","webpack:///./server/utils/validation.js"],"sourcesContent":[" \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadUpdateChunk(chunkId) {\n \t\tvar chunk = require(\"./\" + \"\" + chunkId + \".\" + hotCurrentHash + \".hot-update.js\");\n \t\thotAddUpdateChunk(chunk.id, chunk.modules);\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotDownloadManifest() {\n \t\ttry {\n \t\t\tvar update = require(\"./\" + \"\" + hotCurrentHash + \".hot-update.json\");\n \t\t} catch (e) {\n \t\t\treturn Promise.resolve();\n \t\t}\n \t\treturn Promise.resolve(update);\n \t}\n\n \t//eslint-disable-next-line no-unused-vars\n \tfunction hotDisposeChunk(chunkId) {\n \t\tdelete installedChunks[chunkId];\n \t}\n\n \tvar hotApplyOnUpdate = true;\n \tvar hotCurrentHash = \"0b1578eb950161726b76\"; // eslint-disable-line no-unused-vars\n \tvar hotRequestTimeout = 10000;\n \tvar hotCurrentModuleData = {};\n \tvar hotCurrentChildModule; // eslint-disable-line no-unused-vars\n \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\n \tvar hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateRequire(moduleId) {\n \t\tvar me = installedModules[moduleId];\n \t\tif (!me) return __webpack_require__;\n \t\tvar fn = function(request) {\n \t\t\tif (me.hot.active) {\n \t\t\t\tif (installedModules[request]) {\n \t\t\t\t\tif (installedModules[request].parents.indexOf(moduleId) === -1) {\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\thotCurrentParents = [moduleId];\n \t\t\t\t\thotCurrentChildModule = request;\n \t\t\t\t}\n \t\t\t\tif (me.children.indexOf(request) === -1) {\n \t\t\t\t\tme.children.push(request);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tconsole.warn(\n \t\t\t\t\t\"[HMR] unexpected require(\" +\n \t\t\t\t\t\trequest +\n \t\t\t\t\t\t\") from disposed module \" +\n \t\t\t\t\t\tmoduleId\n \t\t\t\t);\n \t\t\t\thotCurrentParents = [];\n \t\t\t}\n \t\t\treturn __webpack_require__(request);\n \t\t};\n \t\tvar ObjectFactory = function ObjectFactory(name) {\n \t\t\treturn {\n \t\t\t\tconfigurable: true,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: function() {\n \t\t\t\t\treturn __webpack_require__[name];\n \t\t\t\t},\n \t\t\t\tset: function(value) {\n \t\t\t\t\t__webpack_require__[name] = value;\n \t\t\t\t}\n \t\t\t};\n \t\t};\n \t\tfor (var name in __webpack_require__) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(__webpack_require__, name) &&\n \t\t\t\tname !== \"e\" &&\n \t\t\t\tname !== \"t\"\n \t\t\t) {\n \t\t\t\tObject.defineProperty(fn, name, ObjectFactory(name));\n \t\t\t}\n \t\t}\n \t\tfn.e = function(chunkId) {\n \t\t\tif (hotStatus === \"ready\") hotSetStatus(\"prepare\");\n \t\t\thotChunksLoading++;\n \t\t\treturn __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {\n \t\t\t\tfinishChunkLoading();\n \t\t\t\tthrow err;\n \t\t\t});\n\n \t\t\tfunction finishChunkLoading() {\n \t\t\t\thotChunksLoading--;\n \t\t\t\tif (hotStatus === \"prepare\") {\n \t\t\t\t\tif (!hotWaitingFilesMap[chunkId]) {\n \t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t\t\t}\n \t\t\t\t\tif (hotChunksLoading === 0 && hotWaitingFiles === 0) {\n \t\t\t\t\t\thotUpdateDownloaded();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t\tfn.t = function(value, mode) {\n \t\t\tif (mode & 1) value = fn(value);\n \t\t\treturn __webpack_require__.t(value, mode & ~1);\n \t\t};\n \t\treturn fn;\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotCreateModule(moduleId) {\n \t\tvar hot = {\n \t\t\t// private stuff\n \t\t\t_acceptedDependencies: {},\n \t\t\t_declinedDependencies: {},\n \t\t\t_selfAccepted: false,\n \t\t\t_selfDeclined: false,\n \t\t\t_disposeHandlers: [],\n \t\t\t_main: hotCurrentChildModule !== moduleId,\n\n \t\t\t// Module API\n \t\t\tactive: true,\n \t\t\taccept: function(dep, callback) {\n \t\t\t\tif (typeof dep === \"undefined\") hot._selfAccepted = true;\n \t\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function() {};\n \t\t\t\telse hot._acceptedDependencies[dep] = callback || function() {};\n \t\t\t},\n \t\t\tdecline: function(dep) {\n \t\t\t\tif (typeof dep === \"undefined\") hot._selfDeclined = true;\n \t\t\t\telse if (typeof dep === \"object\")\n \t\t\t\t\tfor (var i = 0; i < dep.length; i++)\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n \t\t\t\telse hot._declinedDependencies[dep] = true;\n \t\t\t},\n \t\t\tdispose: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\taddDisposeHandler: function(callback) {\n \t\t\t\thot._disposeHandlers.push(callback);\n \t\t\t},\n \t\t\tremoveDisposeHandler: function(callback) {\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n \t\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t// Management API\n \t\t\tcheck: hotCheck,\n \t\t\tapply: hotApply,\n \t\t\tstatus: function(l) {\n \t\t\t\tif (!l) return hotStatus;\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\taddStatusHandler: function(l) {\n \t\t\t\thotStatusHandlers.push(l);\n \t\t\t},\n \t\t\tremoveStatusHandler: function(l) {\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\n \t\t\t\tif (idx >= 0) hotStatusHandlers.splice(idx, 1);\n \t\t\t},\n\n \t\t\t//inherit from previous dispose call\n \t\t\tdata: hotCurrentModuleData[moduleId]\n \t\t};\n \t\thotCurrentChildModule = undefined;\n \t\treturn hot;\n \t}\n\n \tvar hotStatusHandlers = [];\n \tvar hotStatus = \"idle\";\n\n \tfunction hotSetStatus(newStatus) {\n \t\thotStatus = newStatus;\n \t\tfor (var i = 0; i < hotStatusHandlers.length; i++)\n \t\t\thotStatusHandlers[i].call(null, newStatus);\n \t}\n\n \t// while downloading\n \tvar hotWaitingFiles = 0;\n \tvar hotChunksLoading = 0;\n \tvar hotWaitingFilesMap = {};\n \tvar hotRequestedFilesMap = {};\n \tvar hotAvailableFilesMap = {};\n \tvar hotDeferred;\n\n \t// The update info\n \tvar hotUpdate, hotUpdateNewHash;\n\n \tfunction toModuleId(id) {\n \t\tvar isNumber = +id + \"\" === id;\n \t\treturn isNumber ? +id : id;\n \t}\n\n \tfunction hotCheck(apply) {\n \t\tif (hotStatus !== \"idle\") {\n \t\t\tthrow new Error(\"check() is only allowed in idle status\");\n \t\t}\n \t\thotApplyOnUpdate = apply;\n \t\thotSetStatus(\"check\");\n \t\treturn hotDownloadManifest(hotRequestTimeout).then(function(update) {\n \t\t\tif (!update) {\n \t\t\t\thotSetStatus(\"idle\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\thotRequestedFilesMap = {};\n \t\t\thotWaitingFilesMap = {};\n \t\t\thotAvailableFilesMap = update.c;\n \t\t\thotUpdateNewHash = update.h;\n\n \t\t\thotSetStatus(\"prepare\");\n \t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\thotDeferred = {\n \t\t\t\t\tresolve: resolve,\n \t\t\t\t\treject: reject\n \t\t\t\t};\n \t\t\t});\n \t\t\thotUpdate = {};\n \t\t\tvar chunkId = \"main\";\n \t\t\t{\n \t\t\t\t// eslint-disable-line no-lone-blocks\n \t\t\t\t/*globals chunkId */\n \t\t\t\thotEnsureUpdateChunk(chunkId);\n \t\t\t}\n \t\t\tif (\n \t\t\t\thotStatus === \"prepare\" &&\n \t\t\t\thotChunksLoading === 0 &&\n \t\t\t\thotWaitingFiles === 0\n \t\t\t) {\n \t\t\t\thotUpdateDownloaded();\n \t\t\t}\n \t\t\treturn promise;\n \t\t});\n \t}\n\n \t// eslint-disable-next-line no-unused-vars\n \tfunction hotAddUpdateChunk(chunkId, moreModules) {\n \t\tif (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\n \t\t\treturn;\n \t\thotRequestedFilesMap[chunkId] = false;\n \t\tfor (var moduleId in moreModules) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif (--hotWaitingFiles === 0 && hotChunksLoading === 0) {\n \t\t\thotUpdateDownloaded();\n \t\t}\n \t}\n\n \tfunction hotEnsureUpdateChunk(chunkId) {\n \t\tif (!hotAvailableFilesMap[chunkId]) {\n \t\t\thotWaitingFilesMap[chunkId] = true;\n \t\t} else {\n \t\t\thotRequestedFilesMap[chunkId] = true;\n \t\t\thotWaitingFiles++;\n \t\t\thotDownloadUpdateChunk(chunkId);\n \t\t}\n \t}\n\n \tfunction hotUpdateDownloaded() {\n \t\thotSetStatus(\"ready\");\n \t\tvar deferred = hotDeferred;\n \t\thotDeferred = null;\n \t\tif (!deferred) return;\n \t\tif (hotApplyOnUpdate) {\n \t\t\t// Wrap deferred object in Promise to mark it as a well-handled Promise to\n \t\t\t// avoid triggering uncaught exception warning in Chrome.\n \t\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666\n \t\t\tPromise.resolve()\n \t\t\t\t.then(function() {\n \t\t\t\t\treturn hotApply(hotApplyOnUpdate);\n \t\t\t\t})\n \t\t\t\t.then(\n \t\t\t\t\tfunction(result) {\n \t\t\t\t\t\tdeferred.resolve(result);\n \t\t\t\t\t},\n \t\t\t\t\tfunction(err) {\n \t\t\t\t\t\tdeferred.reject(err);\n \t\t\t\t\t}\n \t\t\t\t);\n \t\t} else {\n \t\t\tvar outdatedModules = [];\n \t\t\tfor (var id in hotUpdate) {\n \t\t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\n \t\t\t\t}\n \t\t\t}\n \t\t\tdeferred.resolve(outdatedModules);\n \t\t}\n \t}\n\n \tfunction hotApply(options) {\n \t\tif (hotStatus !== \"ready\")\n \t\t\tthrow new Error(\"apply() is only allowed in ready status\");\n \t\toptions = options || {};\n\n \t\tvar cb;\n \t\tvar i;\n \t\tvar j;\n \t\tvar module;\n \t\tvar moduleId;\n\n \t\tfunction getAffectedStuff(updateModuleId) {\n \t\t\tvar outdatedModules = [updateModuleId];\n \t\t\tvar outdatedDependencies = {};\n\n \t\t\tvar queue = outdatedModules.slice().map(function(id) {\n \t\t\t\treturn {\n \t\t\t\t\tchain: [id],\n \t\t\t\t\tid: id\n \t\t\t\t};\n \t\t\t});\n \t\t\twhile (queue.length > 0) {\n \t\t\t\tvar queueItem = queue.pop();\n \t\t\t\tvar moduleId = queueItem.id;\n \t\t\t\tvar chain = queueItem.chain;\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (!module || module.hot._selfAccepted) continue;\n \t\t\t\tif (module.hot._selfDeclined) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"self-declined\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tif (module.hot._main) {\n \t\t\t\t\treturn {\n \t\t\t\t\t\ttype: \"unaccepted\",\n \t\t\t\t\t\tchain: chain,\n \t\t\t\t\t\tmoduleId: moduleId\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n \t\t\t\t\tvar parentId = module.parents[i];\n \t\t\t\t\tvar parent = installedModules[parentId];\n \t\t\t\t\tif (!parent) continue;\n \t\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n \t\t\t\t\t\treturn {\n \t\t\t\t\t\t\ttype: \"declined\",\n \t\t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\tparentId: parentId\n \t\t\t\t\t\t};\n \t\t\t\t\t}\n \t\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n \t\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n \t\t\t\t\t\tif (!outdatedDependencies[parentId])\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tdelete outdatedDependencies[parentId];\n \t\t\t\t\toutdatedModules.push(parentId);\n \t\t\t\t\tqueue.push({\n \t\t\t\t\t\tchain: chain.concat([parentId]),\n \t\t\t\t\t\tid: parentId\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t}\n\n \t\t\treturn {\n \t\t\t\ttype: \"accepted\",\n \t\t\t\tmoduleId: updateModuleId,\n \t\t\t\toutdatedModules: outdatedModules,\n \t\t\t\toutdatedDependencies: outdatedDependencies\n \t\t\t};\n \t\t}\n\n \t\tfunction addAllToSet(a, b) {\n \t\t\tfor (var i = 0; i < b.length; i++) {\n \t\t\t\tvar item = b[i];\n \t\t\t\tif (a.indexOf(item) === -1) a.push(item);\n \t\t\t}\n \t\t}\n\n \t\t// at begin all updates modules are outdated\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\n \t\tvar outdatedDependencies = {};\n \t\tvar outdatedModules = [];\n \t\tvar appliedUpdate = {};\n\n \t\tvar warnUnexpectedRequire = function warnUnexpectedRequire() {\n \t\t\tconsole.warn(\n \t\t\t\t\"[HMR] unexpected require(\" + result.moduleId + \") to disposed module\"\n \t\t\t);\n \t\t};\n\n \t\tfor (var id in hotUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\n \t\t\t\tmoduleId = toModuleId(id);\n \t\t\t\t/** @type {TODO} */\n \t\t\t\tvar result;\n \t\t\t\tif (hotUpdate[id]) {\n \t\t\t\t\tresult = getAffectedStuff(moduleId);\n \t\t\t\t} else {\n \t\t\t\t\tresult = {\n \t\t\t\t\t\ttype: \"disposed\",\n \t\t\t\t\t\tmoduleId: id\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\t/** @type {Error|false} */\n \t\t\t\tvar abortError = false;\n \t\t\t\tvar doApply = false;\n \t\t\t\tvar doDispose = false;\n \t\t\t\tvar chainInfo = \"\";\n \t\t\t\tif (result.chain) {\n \t\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n \t\t\t\t}\n \t\t\t\tswitch (result.type) {\n \t\t\t\t\tcase \"self-declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"declined\":\n \t\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n \t\t\t\t\t\tif (!options.ignoreDeclined)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n \t\t\t\t\t\t\t\t\tresult.moduleId +\n \t\t\t\t\t\t\t\t\t\" in \" +\n \t\t\t\t\t\t\t\t\tresult.parentId +\n \t\t\t\t\t\t\t\t\tchainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"unaccepted\":\n \t\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n \t\t\t\t\t\tif (!options.ignoreUnaccepted)\n \t\t\t\t\t\t\tabortError = new Error(\n \t\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"accepted\":\n \t\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n \t\t\t\t\t\tdoApply = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase \"disposed\":\n \t\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n \t\t\t\t\t\tdoDispose = true;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n \t\t\t\t}\n \t\t\t\tif (abortError) {\n \t\t\t\t\thotSetStatus(\"abort\");\n \t\t\t\t\treturn Promise.reject(abortError);\n \t\t\t\t}\n \t\t\t\tif (doApply) {\n \t\t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\n \t\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n \t\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n \t\t\t\t\t\tif (\n \t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(\n \t\t\t\t\t\t\t\tresult.outdatedDependencies,\n \t\t\t\t\t\t\t\tmoduleId\n \t\t\t\t\t\t\t)\n \t\t\t\t\t\t) {\n \t\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n \t\t\t\t\t\t\taddAllToSet(\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n \t\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (doDispose) {\n \t\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n \t\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Store self accepted outdated modules to require them later by the module system\n \t\tvar outdatedSelfAcceptedModules = [];\n \t\tfor (i = 0; i < outdatedModules.length; i++) {\n \t\t\tmoduleId = outdatedModules[i];\n \t\t\tif (\n \t\t\t\tinstalledModules[moduleId] &&\n \t\t\t\tinstalledModules[moduleId].hot._selfAccepted\n \t\t\t)\n \t\t\t\toutdatedSelfAcceptedModules.push({\n \t\t\t\t\tmodule: moduleId,\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\n \t\t\t\t});\n \t\t}\n\n \t\t// Now in \"dispose\" phase\n \t\thotSetStatus(\"dispose\");\n \t\tObject.keys(hotAvailableFilesMap).forEach(function(chunkId) {\n \t\t\tif (hotAvailableFilesMap[chunkId] === false) {\n \t\t\t\thotDisposeChunk(chunkId);\n \t\t\t}\n \t\t});\n\n \t\tvar idx;\n \t\tvar queue = outdatedModules.slice();\n \t\twhile (queue.length > 0) {\n \t\t\tmoduleId = queue.pop();\n \t\t\tmodule = installedModules[moduleId];\n \t\t\tif (!module) continue;\n\n \t\t\tvar data = {};\n\n \t\t\t// Call dispose handlers\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n \t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n \t\t\t\tcb = disposeHandlers[j];\n \t\t\t\tcb(data);\n \t\t\t}\n \t\t\thotCurrentModuleData[moduleId] = data;\n\n \t\t\t// disable module (this disables requires from this module)\n \t\t\tmodule.hot.active = false;\n\n \t\t\t// remove module from cache\n \t\t\tdelete installedModules[moduleId];\n\n \t\t\t// when disposing there is no need to call dispose handler\n \t\t\tdelete outdatedDependencies[moduleId];\n\n \t\t\t// remove \"parents\" references from all children\n \t\t\tfor (j = 0; j < module.children.length; j++) {\n \t\t\t\tvar child = installedModules[module.children[j]];\n \t\t\t\tif (!child) continue;\n \t\t\t\tidx = child.parents.indexOf(moduleId);\n \t\t\t\tif (idx >= 0) {\n \t\t\t\t\tchild.parents.splice(idx, 1);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// remove outdated dependency from module children\n \t\tvar dependency;\n \t\tvar moduleOutdatedDependencies;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n \t\t\t\t\t\tidx = module.children.indexOf(dependency);\n \t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Not in \"apply\" phase\n \t\thotSetStatus(\"apply\");\n\n \t\thotCurrentHash = hotUpdateNewHash;\n\n \t\t// insert new code\n \t\tfor (moduleId in appliedUpdate) {\n \t\t\tif (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\n \t\t\t}\n \t\t}\n\n \t\t// call accept handlers\n \t\tvar error = null;\n \t\tfor (moduleId in outdatedDependencies) {\n \t\t\tif (\n \t\t\t\tObject.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)\n \t\t\t) {\n \t\t\t\tmodule = installedModules[moduleId];\n \t\t\t\tif (module) {\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\n \t\t\t\t\tvar callbacks = [];\n \t\t\t\t\tfor (i = 0; i < moduleOutdatedDependencies.length; i++) {\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[i];\n \t\t\t\t\t\tcb = module.hot._acceptedDependencies[dependency];\n \t\t\t\t\t\tif (cb) {\n \t\t\t\t\t\t\tif (callbacks.indexOf(cb) !== -1) continue;\n \t\t\t\t\t\t\tcallbacks.push(cb);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tfor (i = 0; i < callbacks.length; i++) {\n \t\t\t\t\t\tcb = callbacks[i];\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tcb(moduleOutdatedDependencies);\n \t\t\t\t\t\t} catch (err) {\n \t\t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n \t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\t\tdependencyId: moduleOutdatedDependencies[i],\n \t\t\t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// Load self accepted modules\n \t\tfor (i = 0; i < outdatedSelfAcceptedModules.length; i++) {\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\n \t\t\tmoduleId = item.module;\n \t\t\thotCurrentParents = [moduleId];\n \t\t\ttry {\n \t\t\t\t__webpack_require__(moduleId);\n \t\t\t} catch (err) {\n \t\t\t\tif (typeof item.errorHandler === \"function\") {\n \t\t\t\t\ttry {\n \t\t\t\t\t\titem.errorHandler(err);\n \t\t\t\t\t} catch (err2) {\n \t\t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n \t\t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\t\terror: err2,\n \t\t\t\t\t\t\t\toriginalError: err\n \t\t\t\t\t\t\t});\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\t\tif (!error) error = err2;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (options.onErrored) {\n \t\t\t\t\t\toptions.onErrored({\n \t\t\t\t\t\t\ttype: \"self-accept-errored\",\n \t\t\t\t\t\t\tmoduleId: moduleId,\n \t\t\t\t\t\t\terror: err\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\tif (!options.ignoreErrored) {\n \t\t\t\t\t\tif (!error) error = err;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\t// handle errors in accept handlers and self accepted module load\n \t\tif (error) {\n \t\t\thotSetStatus(\"fail\");\n \t\t\treturn Promise.reject(error);\n \t\t}\n\n \t\thotSetStatus(\"idle\");\n \t\treturn new Promise(function(resolve) {\n \t\t\tresolve(outdatedModules);\n \t\t});\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {},\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(0)(__webpack_require__.s = 0);\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(updatedModules, renewedModules) {\n\tvar unacceptedModules = updatedModules.filter(function(moduleId) {\n\t\treturn renewedModules && renewedModules.indexOf(moduleId) < 0;\n\t});\n\tvar log = require(\"./log\");\n\n\tif (unacceptedModules.length > 0) {\n\t\tlog(\n\t\t\t\"warning\",\n\t\t\t\"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)\"\n\t\t);\n\t\tunacceptedModules.forEach(function(moduleId) {\n\t\t\tlog(\"warning\", \"[HMR]  - \" + moduleId);\n\t\t});\n\t}\n\n\tif (!renewedModules || renewedModules.length === 0) {\n\t\tlog(\"info\", \"[HMR] Nothing hot updated.\");\n\t} else {\n\t\tlog(\"info\", \"[HMR] Updated modules:\");\n\t\trenewedModules.forEach(function(moduleId) {\n\t\t\tif (typeof moduleId === \"string\" && moduleId.indexOf(\"!\") !== -1) {\n\t\t\t\tvar parts = moduleId.split(\"!\");\n\t\t\t\tlog.groupCollapsed(\"info\", \"[HMR]  - \" + parts.pop());\n\t\t\t\tlog(\"info\", \"[HMR]  - \" + moduleId);\n\t\t\t\tlog.groupEnd(\"info\");\n\t\t\t} else {\n\t\t\t\tlog(\"info\", \"[HMR]  - \" + moduleId);\n\t\t\t}\n\t\t});\n\t\tvar numberIds = renewedModules.every(function(moduleId) {\n\t\t\treturn typeof moduleId === \"number\";\n\t\t});\n\t\tif (numberIds)\n\t\t\tlog(\n\t\t\t\t\"info\",\n\t\t\t\t\"[HMR] Consider using the NamedModulesPlugin for module names.\"\n\t\t\t);\n\t}\n};\n","var logLevel = \"info\";\n\nfunction dummy() {}\n\nfunction shouldLog(level) {\n\tvar shouldLog =\n\t\t(logLevel === \"info\" && level === \"info\") ||\n\t\t([\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\") ||\n\t\t([\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\");\n\treturn shouldLog;\n}\n\nfunction logGroup(logFn) {\n\treturn function(level, msg) {\n\t\tif (shouldLog(level)) {\n\t\t\tlogFn(msg);\n\t\t}\n\t};\n}\n\nmodule.exports = function(level, msg) {\n\tif (shouldLog(level)) {\n\t\tif (level === \"info\") {\n\t\t\tconsole.log(msg);\n\t\t} else if (level === \"warning\") {\n\t\t\tconsole.warn(msg);\n\t\t} else if (level === \"error\") {\n\t\t\tconsole.error(msg);\n\t\t}\n\t}\n};\n\nvar group = console.group || dummy;\nvar groupCollapsed = console.groupCollapsed || dummy;\nvar groupEnd = console.groupEnd || dummy;\n\nmodule.exports.group = logGroup(group);\n\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\n\nmodule.exports.groupEnd = logGroup(groupEnd);\n\nmodule.exports.setLogLevel = function(level) {\n\tlogLevel = level;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/*globals __resourceQuery */\nif (module.hot) {\n\tvar hotPollInterval = +__resourceQuery.substr(1) || 10 * 60 * 1000;\n\tvar log = require(\"./log\");\n\n\tvar checkForUpdate = function checkForUpdate(fromUpdate) {\n\t\tif (module.hot.status() === \"idle\") {\n\t\t\tmodule.hot\n\t\t\t\t.check(true)\n\t\t\t\t.then(function(updatedModules) {\n\t\t\t\t\tif (!updatedModules) {\n\t\t\t\t\t\tif (fromUpdate) log(\"info\", \"[HMR] Update applied.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\trequire(\"./log-apply-result\")(updatedModules, updatedModules);\n\t\t\t\t\tcheckForUpdate(true);\n\t\t\t\t})\n\t\t\t\t.catch(function(err) {\n\t\t\t\t\tvar status = module.hot.status();\n\t\t\t\t\tif ([\"abort\", \"fail\"].indexOf(status) >= 0) {\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] Cannot apply update.\");\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] \" + err.stack || err.message);\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] You need to restart the application!\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog(\"warning\", \"[HMR] Update failed: \" + err.stack || err.message);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t};\n\tsetInterval(checkForUpdate, hotPollInterval);\n} else {\n\tthrow new Error(\"[HMR] Hot Module Replacement is disabled.\");\n}\n","import passport from 'passport';\nimport mongoose from 'mongoose';\n\nimport { userValidatorSchema, validateUserForm } from './userValidator';\n\nconst User = mongoose.model('User');\n\nconst loginForm = (req, res) => res.render('login');\n\n// logs in a user\nconst loginUser = passport.authenticate('local', {\n  successReturnToOrRedirect: '/',\n  failureRedirect: '/login',\n  failureFlash: true,\n  successFlash: 'You have logged in',\n});\n\nconst logoutUser = (req, res) => {\n  req.logout();\n  req.flash('info', 'You have logged out');\n  res.redirect('/');\n};\n\n// checks credentials but does not log them in\nconst authLocal = passport.authorize('local', {\n  failureRedirect: '/link/local',\n  failureFlash: 'Email or password is invalid',\n});\n\nconst linkLocalForm = (req, res) => res.render('link_local');\n\nconst genOauthLogin = (provider, config = {}) => ({\n  auth(req, res, next) {\n    const fn = req.user ? passport.authorize : passport.authenticate;\n    return fn.call(passport, provider, config.scope && { scope: config.scope })(req, res, next);\n  },\n  authCb(req, res, next) {\n    const fn = req.user ? passport.authorize : passport.authenticate;\n    const routes = req.user ?\n      {\n        failureRedirect: '/profile',\n        failureFlash: `${provider} account was not linked`,\n      } :\n      (err, user, info) => {\n        if (err) { return next(err); }\n        if (!user) {\n          req.flash('error', `Permission to login via ${provider} was denied`);\n          return res.redirect('/login');\n        }\n\n        return req.login(user, (error) => {\n          if (error) { return next(error); }\n          req.flash('success', `You have logged in, ${user[provider].displayName || user[provider].username}`);\n          if (info.firstLogin) { return res.redirect('/profile'); }\n          return res.redirect('/');\n        });\n      };\n    return fn.call(passport, provider, routes)(req, res, next);\n  },\n});\n\nconst linkAccount = async (req, res, next) => {\n  const { user, account } = req;\n\n  // user who has already logged in has authorised another account so we need to link them\n  if (user && account) {\n    const accountObj = account.toObject({\n      transform(doc, ret) {\n        const newRet = Object.assign({}, ret);\n        delete newRet.__v;\n        delete newRet._id;\n        return newRet;\n      },\n    });\n    if (accountObj.local) {\n      /* if req.user is a social account and they try to link to local, then we must delete the\n          local account otherwise there will be a duplicate in the db when we try to add the local\n          info to the social account. Since the user model doesn't allow duplicate emails, it will\n          throw an error if we didn't do this */\n      await User.deleteOne({ 'local.email': accountObj.local.email });\n    }\n    // merge accounts but preserve original username\n    Object.assign(user, accountObj, { username: user.username });\n    await user.save();\n    await account.remove();\n    req.flash('success', 'Accounts have been linked');\n    return res.redirect('/profile');\n  }\n  return next();\n};\n\nconst unlinkAccount = async (req, res, next) => {\n  const type = req.params.account;\n  const types = ['twitter', 'google', 'facebook', 'local'];\n  const { user } = req;\n  if (!types.includes(type)) {\n    const err = new Error('Unknown account type');\n    err.status = 400;\n    return next(err);\n  }\n\n  if (user.accountsTotal === 1) {\n    req.flash('error', 'Unable to unlink solo account');\n    return res.redirect('/profile');\n  }\n\n  if (type === 'local') {\n    const local = Object.assign({}, user.local);\n    user.local = undefined;\n    await user.save();\n    await User.create({ local, username: await User.genUniqueUsername() });\n  } else {\n    user[type].token = undefined;\n    await user.save();\n  }\n  req.flash('success', 'Account has been unlinked');\n  return res.redirect('/profile');\n};\n\nconst profile = (req, res) => {\n  const { user } = req;\n\n  const linkedAccounts = Object.entries(user.toObject()).reduce((all, [type, acc]) => {\n    if ((type === 'local' && acc.email) || acc.token) {\n      all[type] = acc.email || acc.displayName;\n    }\n    return all;\n  }, {});\n\n  const linkable = ['local', 'twitter', 'google', 'facebook']\n    .filter(type => !linkedAccounts[type]);\n\n  res.render('profile', {\n    body: { username: req.user.username, email: req.user.local.email },\n    linkedAccounts,\n    linkable,\n  });\n};\n\nconst preValidateProfile = (req, res, next) => {\n  if (req.body.password) {\n    return next('route');\n  }\n  return next();\n};\n\nconst validateProfile = validateUserForm(userValidatorSchema('username', 'email'), 'profile');\nconst validateProfilePassword = validateUserForm(userValidatorSchema('username', 'email', 'password', 'password-confirm'), 'profile');\n\nconst updateProfile = async (req, res) => {\n  const { username, email, password } = req.body;\n  if (username !== req.user.username) {\n    req.user.username = username;\n  }\n\n  if (req.user.local && email !== req.user.local.email) {\n    req.user.local.email = email;\n  }\n\n  if (password) {\n    req.user.local.password = await User.hashPassword(password);\n  }\n\n  await req.user.save();\n  req.flash('success', 'Account updated');\n  res.redirect('/profile');\n};\n\nexport default {\n  loginForm,\n  loginUser,\n  logoutUser,\n  genOauthLogin,\n  profile,\n  authLocal,\n  linkAccount,\n  unlinkAccount,\n  linkLocalForm,\n  validateProfile,\n  updateProfile,\n  preValidateProfile,\n  validateProfilePassword,\n};\n","import mongoose from 'mongoose';\nimport crypto from 'crypto';\nimport rp from 'request-promise';\n\nimport { userValidatorSchema, validateUserForm } from './userValidator';\nimport { catchAsyncError } from '../utils/helpers';\nimport mailer from '../mailer';\n\nconst User = mongoose.model('User');\nconst EmailVerifyToken = mongoose.model('EmailVerifyToken');\n\nconst signupForm = (req, res) => {\n  res.render('signup', { recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY });\n};\n\nconst validateNewUser = validateUserForm(userValidatorSchema(), 'signup');\n\nconst validateHuman = failureView => async (req, res, next) => {\n  const options = {\n    method: 'POST',\n    uri: 'https://www.google.com/recaptcha/api/siteverify',\n    formData: {\n      secret: process.env.G_RECAPTCHA_SECRET,\n      response: req.body['g-recaptcha-response'],\n    },\n    json: true,\n  };\n\n  try {\n    const captchaRes = await rp(options);\n\n    if (captchaRes.success) {\n      return next();\n    }\n  } catch (err) {\n    return next(err);\n  }\n\n  req.flash('error', 'reCaptcha failed. Please try again');\n  return res.render(failureView, {\n    body: req.body,\n    flashes: req.flash(),\n    recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY,\n  });\n};\n\nconst createOne = async (req, res, next) => {\n  const { email, password, username } = req.body;\n  try {\n    const user = await User.create({\n      local: { email, password: await User.hashPassword(password) },\n      username,\n    });\n\n    req.emailToken = await EmailVerifyToken.createToken(user.id);\n    next();\n  } catch (err) {\n    if (err.errors) {\n      const keys = Object.keys(err.errors);\n      const flashes = keys.map(key => err.errors[key].message);\n      req.flash('error', flashes);\n      res.render('signup', { body: { username, email }, flashes: req.flash() });\n    } else {\n      next(err);\n    }\n  }\n};\n\nconst sendConfirmEmail = (req, res) => {\n  const { email, username } = req.body;\n\n  mailer.send({\n    template: 'verifyEmail',\n    message: {\n      to: email,\n    },\n    locals: {\n      name: username,\n      confirmURL: `${req.protocol}://${req.hostname}/confirm/${req.emailToken.token}`,\n    },\n  });\n\n  req.flash('info', `An email has been sent to ${email}. Please confirm your email to complete sign up.`);\n  res.redirect('/');\n};\n\nconst confirmEmail = async (req, res) => {\n  const token = await EmailVerifyToken.findOneAndRemove({ token: req.params.token }).populate('user');\n  if (!token) {\n    req.flash('error', `Email verification invalid. Either the link does not match the one provided\n      in the email or the link may have expired. <a href=\"/resend\">Resend email confirmation</a>`);\n    return res.redirect('/');\n  }\n\n  const { user } = token;\n  user.local.isVerified = true;\n  await user.save();\n  await req.login(user);\n  req.flash('success', 'Your email has been confirmed. You are now logged in');\n  return res.redirect('/');\n};\n\n/* Resend confirmation email */\n\nconst requestResend = (req, res) => {\n  res.render('confirmEmail', { recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY });\n};\n\nconst validateEmail = validateUserForm(userValidatorSchema('email'), 'confirmEmail');\n\nconst resend = async (req, res, next) => {\n  const user = await User.findOne({ 'local.email': req.body.email });\n\n  if (!user || !user.local) {\n    req.flash('info', 'An account with this email does not exist');\n    return res.render('confirmEmail', { body: req.body, flashes: req.flash() });\n  }\n\n  if (user.local && user.local.isVerified) {\n    req.flash('info', 'The email for this account is already confirmed');\n    return res.redirect('/');\n  }\n\n  req.emailToken = await EmailVerifyToken.findOneOrCreate(user.id);\n  req.body.username = user.username;\n  return next();\n};\n\n/* Reset password */\n\nconst forgotPasswordForm = (req, res) => {\n  res.render('forgotPassword', { recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY });\n};\n\nconst forgotPassword = async (req, res, next) => {\n  const user = await User.findOne({ 'local.email': req.body.email });\n\n  if (!user || !user.local) {\n    req.flash('info', 'An account with this email does not exist');\n    return res.render('forgotPassword', { body: req.body, flashes: req.flash() });\n  }\n\n  user.passwordResetToken = crypto.randomBytes(20).toString('hex');\n  user.passwordResetExpires = Date.now() + 3600000;\n  await user.save();\n  req.emailToken = user.passwordResetToken;\n  req.body.username = user.username;\n  return next();\n};\n\nconst sendResetEmail = (req, res) => {\n  const { email, username } = req.body;\n\n  mailer.send({\n    template: 'resetPassword',\n    message: {\n      to: email,\n    },\n    locals: {\n      name: username,\n      resetURL: `${req.protocol}://${req.hostname}/reset/${req.emailToken}`,\n    },\n  });\n\n  req.flash('info', `An email has been sent to ${email} with instructions to reset your password.`);\n  res.redirect('/');\n};\n\nconst validResetToken = async (req, res, next) => {\n  const user = await User.findOne({\n    passwordResetToken: req.params.token,\n    passwordResetExpires: { $gt: Date.now() },\n  });\n  if (!user) {\n    req.flash('error', 'This password reset is invalid or expired. Please request a new one');\n    return res.redirect('/forgot');\n  }\n  req.user = user;\n  return next();\n};\n\nconst resetPasswordForm = async (req, res) => {\n  res.render('resetPassword');\n};\n\nconst validatePassword = validateUserForm(userValidatorSchema('password', 'password-confirm'), 'resetPassword');\n\nconst resetPassword = async (req, res, next) => {\n  const { user } = req;\n\n  user.local.password = await User.hashPassword(req.body.password);\n  user.passwordResetExpires = undefined;\n  user.passwordResetToken = undefined;\n  await user.save();\n  await req.login(user);\n  next();\n};\n\nconst sendPasswordUpdatedEmail = async (req, res) => {\n  const { local: { email }, username } = req.user;\n\n  mailer.send({\n    template: 'updatedPassword',\n    message: {\n      to: email,\n    },\n    locals: {\n      name: username,\n    },\n  });\n\n  req.flash('success', 'Password has been updated');\n  res.redirect('/');\n};\n\nconst getOne = async (req, res) => {\n  const user = await User.findById(req.user.id);\n  res.send(`get user\\n ${user}`);\n};\n\nconst updateOne = (req, res) => {\n  res.send(`update user\\n ${req.docFromId}`);\n};\n\nconst deleteOne = (req, res) => {\n  res.send(`delete user\\n ${req.docFromId}`);\n};\n\nexport default {\n  createOne: catchAsyncError(createOne),\n  getOne: catchAsyncError(getOne),\n  updateOne: catchAsyncError(updateOne),\n  deleteOne: catchAsyncError(deleteOne),\n  signupForm,\n  validateNewUser,\n  confirmEmail: catchAsyncError(confirmEmail),\n  requestResend,\n  validateEmail,\n  resend,\n  sendConfirmEmail,\n  forgotPasswordForm,\n  forgotPassword: catchAsyncError(forgotPassword),\n  sendResetEmail,\n  resetPasswordForm,\n  validatePassword,\n  resetPassword: catchAsyncError(resetPassword),\n  validResetToken: catchAsyncError(validResetToken),\n  sendPasswordUpdatedEmail: catchAsyncError(sendPasswordUpdatedEmail),\n  validateHuman,\n};\n","import _ from 'lodash';\nimport { validationResult, checkSchema } from 'express-validator/check';\n\nconst userSchema = {\n  username: {\n    in: 'body',\n    isLength: {\n      errorMessage: 'Username must not be empty',\n      options: { min: 1 },\n    },\n    custom: {\n      options: (value) => {\n        const guestRe = /^guest-\\w+$/i;\n        const validUserRe = /^[\\w-]+$/;\n        if (!validUserRe.test(value)) {\n          throw new Error(\"Username must be letters, numbers, '_', ' -' only\");\n        } else if (guestRe.test(value)) {\n          throw new Error(\"Usernames beginning with 'guest-' are reserved for unregistered users\");\n        }\n        return true;\n      },\n    },\n    trim: true,\n  },\n  email: {\n    in: 'body',\n    isEmail: {\n      errorMessage: 'Email address is not valid',\n    },\n    trim: true,\n    normalizeEmail: {\n      options: {\n        all_lowercase: true,\n        gmail_convert_googlemaildotcom: true,\n        gmail_remove_dots: true,\n        gmail_remove_subaddress: true,\n      },\n    },\n  },\n  password: {\n    in: 'body',\n    isLength: {\n      errorMessage: 'Password must be at least 5 characters long',\n      options: { min: 5 },\n    },\n    trim: true,\n  },\n  'password-confirm': {\n    in: 'body',\n    custom: {\n      options: (value, { req }) => {\n        if (req.body.password !== value) {\n          throw new Error('Password confirmation does not match password field');\n        }\n        return true;\n      },\n    },\n  },\n};\n\nconst userValidatorSchema = (...fields) =>\n  (fields.length ? _.pick(userSchema, fields) : userSchema);\n\nconst validateUserForm = (schema, view) => [\n  checkSchema(schema),\n  (req, res, next) => {\n    const errors = validationResult(req).formatWith(({ msg }) => msg);\n    if (errors.isEmpty()) {\n      next();\n    } else {\n      req.flash('error', errors.array({ onlyFirstError: true }));\n      res.render(view, {\n        body: req.body,\n        flashes: req.flash(),\n        recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY });\n    }\n  },\n];\n\nexport { userValidatorSchema, validateUserForm };\n","import mongoose from 'mongoose';\nimport './models';\n\nconst connect = async () => mongoose.connect(process.env.MONGODB_URI);\n\nexport default connect;\n\n","/* eslint-disable no-console */\n\nimport server, { io } from './server';\n\nconst port = process.env.PORT || 4000;\nlet cServer = server;\nlet cIo = io;\n\nif (module.hot) {\n  module.hot.accept('./server', () => {\n    console.log('Re-attaching event listeners to updated server module');\n    cServer.close();\n    server.listen(port);\n    cServer = server;\n\n    cIo.close();\n    io.attach(cServer);\n    cIo = io;\n  });\n}\n\nserver.listen(port, () => {\n  console.log(`Server started on port ${port}`);\n});\n","import Email from 'email-templates';\nimport path from 'path';\n\nconst email = new Email({\n  message: {\n    from: 'no-reply@timiscoding.me',\n  },\n  // send: true, // uncomment to send emails in dev env\n  transport: {\n    port: process.env.MAILER_PORT,\n    host: process.env.MAILER_HOST,\n    auth: {\n      user: process.env.MAILER_USERNAME,\n      pass: process.env.MAILER_PASSWORD,\n    },\n  },\n  juice: true,\n  juiceResources: {\n    webResources: {\n      relativeTo: path.join(__dirname, '../views/emails/build'),\n    },\n  },\n  views: {\n    root: path.join(__dirname, '../views/emails'),\n  },\n});\n\nexport default email;\n","import express from 'express';\nimport path from 'path';\nimport bodyParser from 'body-parser';\nimport passport from 'passport';\nimport Session from 'express-session';\nimport flash from 'connect-flash';\nimport mongoose from 'mongoose';\n\nconst sessionConfig = {\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n};\n\nif (process.env.NODE_ENV === 'production') {\n  const MongoStore = require('connect-mongo')(Session);\n  sessionConfig.store = new MongoStore({\n    mongooseConnection: mongoose.connection,\n    autoRemove: 'native',\n  });\n} else if (process.env.NODE_ENV === 'development') {\n  const FileStore = require('session-file-store')(Session);\n  sessionConfig.store = new FileStore();\n}\n\nexport const session = Session(sessionConfig);\n\nexport default [\n  express.static(path.join(__dirname, '../../public')),\n  bodyParser.json(),\n  bodyParser.urlencoded({ extended: true }),\n  session,\n  passport.initialize(),\n  passport.session(),\n  flash(),\n];\n","import mongoose from 'mongoose';\nimport crypto from 'crypto';\n\nconst emailVerifyTokenSchema = new mongoose.Schema({\n  user: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n  },\n  createdAt: {\n    type: Date,\n    expires: '5 min',\n    default: Date.now,\n  },\n  token: {\n    type: String,\n    required: true,\n  },\n});\n\nconst token = () => crypto.randomBytes(20).toString('hex');\n\nemailVerifyTokenSchema.statics.findOneOrCreate = async function findOneOrCreate(userId) {\n  const Token = this;\n  if (userId) {\n    const foundToken = await Token.findOne({ user: userId });\n\n    return foundToken || Token.create({\n      user: userId,\n      token: token(),\n    });\n  }\n\n  return new Error('User id not given');\n};\n\nemailVerifyTokenSchema.statics.createToken = async function createToken(userId) {\n  const Token = this;\n  return Token.create({\n    user: userId,\n    token: token(),\n  });\n};\n\nexport default mongoose.model('EmailVerifyToken', emailVerifyTokenSchema);\n","export { default as User } from './user.model';\nexport { default as EmailVerifyToken } from './emailVerifyToken.model';\n","import mongoose from 'mongoose';\n\nconst messageSchema = new mongoose.Schema({\n  createdAt: {\n    type: Date,\n    default: Date.now,\n  },\n  to: {\n    type: String,\n    index: true,\n    required: true,\n  },\n  from: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n  },\n  content: {\n    type: String,\n    trim: true,\n    minLength: 1,\n    required: true,\n  },\n});\n\nexport default mongoose.model('Message', messageSchema);\n","import mongoose from 'mongoose';\n\nconst roomSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: true,\n    minLength: 1,\n    trim: true,\n  },\n});\n\nexport default mongoose.model('Room', roomSchema);\n","import mongoose from 'mongoose';\nimport bcrypt from 'bcrypt';\nimport isEmail from 'validator/lib/isEmail';\nimport beautifyUnique from 'mongoose-beautiful-unique-validation';\nimport _ from 'lodash';\n\nconst userSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: 'Username is required',\n    unique: 'Username already taken',\n    sparse: true,\n    lowercase: true,\n    trim: true,\n    match: [/^[\\w-]+$/, \"Username must contain alphanumeric, '-', '_' characters only\"],\n  },\n  local: {\n    email: {\n      type: String,\n      unique: 'An account with email {VALUE} already exists',\n      sparse: true, // allows us to add documents without unique fields\n      trim: true,\n      lowercase: true,\n      validate: [isEmail, 'Email is not valid'],\n    },\n    password: {\n      type: String,\n      trim: true,\n      minlength: 5,\n    },\n    isVerified: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  facebook: {\n    id: String,\n    token: String,\n    displayName: String,\n    email: String,\n  },\n  twitter: {\n    id: String,\n    token: String,\n    displayName: String,\n    username: String,\n  },\n  google: {\n    id: String,\n    token: String,\n    displayName: String,\n    email: String,\n  },\n  passwordResetToken: String,\n  passwordResetExpires: Date,\n});\n\nuserSchema.methods.isValidPassword = function isValidPassword(password) {\n  return bcrypt.compare(password, this.local.password);\n};\n\nconst types = ['twitter', 'google', 'facebook', 'local'];\nuserSchema.methods.accountsTotal = function accountsTotal() {\n  return Object.keys(this.toObject()).reduce((total, f) => {\n    if (types.includes(f)) {\n      if (f === 'local' || (f !== 'local' && this[f].token)) {\n        return total + 1;\n      }\n    }\n    return total;\n  }, 0);\n};\n\nuserSchema.statics.hashPassword = function hashPassword(plaintextPassword) {\n  if (!plaintextPassword) {\n    throw new Error('Password cannot be blank');\n  }\n  return bcrypt.hash(plaintextPassword, 12);\n};\n\nuserSchema.statics.genUniqueUsername = async function genUniqueUsername(name = 'anon') {\n  const snakeCase = name.toLowerCase().replace(/ /g, '_');\n  const usernameRegex = new RegExp(`^${snakeCase}\\d*$`);\n  const usernames = await this.find({ username: usernameRegex }, 'username');\n  let newUsername = snakeCase;\n  // find the first unique username with format username<incrementing number>\n  for (let i = 0; _.find(usernames, { username: newUsername }); i += 1) {\n    newUsername = snakeCase + (usernames.length + i);\n  }\n  return newUsername;\n};\n\n// if client tries creating a duplicate on a unique field, it will produce a low level\n// mongo db error. This plugin transforms that error into a mongoose validation error\n// that exists in an 'errors' object\nuserSchema.plugin(beautifyUnique);\n\nexport default mongoose.model('User', userSchema);\n","import passport from 'passport';\nimport LocalStrategy from 'passport-local';\nimport FacebookStrategy from 'passport-facebook';\nimport TwitterStrategy from 'passport-twitter';\nimport { OAuth2Strategy as GoogleStrategy } from 'passport-google-oauth';\nimport mongoose from 'mongoose';\nimport _ from 'lodash';\n\nconst User = mongoose.model('User');\n\npassport.use(new LocalStrategy(\n  { usernameField: 'email', passReqToCallback: true },\n  async (req, email, password, done) => {\n    try {\n      const user = await User.findOne({ 'local.email': email });\n      if (!user) {\n        return done(null, false, { message: 'Email or password is invalid' });\n      }\n\n      const isValidPassword = await user.isValidPassword(password);\n      if (!isValidPassword) {\n        return done(null, false, { message: 'Email or password is invalid' });\n      }\n\n      if (!user.local.isVerified) {\n        return done(null, false, { message: 'The email has not been verified for this account. <a href=\"/resend\">Resend email confirmation</a>' });\n      }\n\n      /* user is either\n         a) already logged in via oauth and trying to link this local account so the user will be\n         injected into req.account\n         b) logging into their local account so the user will be injected into req.user */\n      return done(null, user);\n    } catch (err) {\n      return done(err, null, { message: 'Could not authenticate. Please try again' });\n    }\n  },\n));\n\nconst getEmail = profile => profile.emails && profile.emails.length && profile.emails[0].value;\nconst createAccount = async (provider, token, profile) => User.create({\n  [provider]: {\n    id: profile.id,\n    displayName: profile.displayName,\n    token,\n    email: getEmail(profile),\n  },\n  username: await User.genUniqueUsername(profile.username || profile.displayName),\n});\n\nconst genOauthCb = provider => async (req, accessToken, refreshTokenOrSecret, profile, done) => {\n  try {\n    let user = await User.findOne({ [`${provider}.id`]: profile.id });\n    if (!req.user) { // not already logged in\n      if (user) {\n        if (!user[provider].token) { // user unlinked this account but has logged in later\n          user[provider] = {\n            id: profile.id,\n            displayName: profile.displayName,\n            token: accessToken,\n            email: getEmail(profile),\n          };\n          user = await user.save();\n        }\n        return done(null, user);\n      }\n\n      user = await createAccount(provider, accessToken, profile);\n\n      /* when a user logs in for the first time, we need a way to inform the authController so that\n         they can send them to a profile page to let them change their username if they want.\n         firstLogin is my own custom prop that will be sent to the custom callback whenever\n         passport.auth(enticate|orize)() is called\n         */\n      return done(null, user, { firstLogin: true });\n    }\n    /* user already logged in and trying to link another account  */\n\n    /* if user tries to link an already linked account, just return the original user */\n    if (user) {\n      /* user previously unlinked account and now wants to relink it.\n        we must update the token and other profile info */\n      if (!user[provider].token) {\n        user = await createAccount(provider, accessToken, profile);\n      }\n      return done(null, user);\n    }\n\n    /* user linking an account they have never authorised before so lets create it first */\n    user = await createAccount(provider, accessToken, profile);\n\n    return done(null, user);\n  } catch (err) {\n    return done(err, false, { message: 'Could not authenticate. Please try again' });\n  }\n};\n\npassport.use(new FacebookStrategy(\n  {\n    clientID: process.env.FACEBOOK_APP_ID,\n    clientSecret: process.env.FACEBOOK_APP_SECRET,\n    callbackURL: `${process.env.DOMAIN}/auth/facebook/callback`,\n    profileFields: ['email', 'displayName'],\n    passReqToCallback: true,\n  },\n  genOauthCb('facebook'),\n));\n\npassport.use(new TwitterStrategy(\n  {\n    consumerKey: process.env.TWITTER_CONSUMER_KEY,\n    consumerSecret: process.env.TWITTER_CONSUMER_SECRET,\n    callbackURL: `${process.env.DOMAIN}/auth/twitter/callback`,\n    passReqToCallback: true,\n  },\n  genOauthCb('twitter'),\n));\n\npassport.use(new GoogleStrategy(\n  {\n    clientID: process.env.GOOGLE_APP_ID,\n    clientSecret: process.env.GOOGLE_APP_SECRET,\n    callbackURL: `${process.env.DOMAIN}/auth/google/callback`,\n    passReqToCallback: true,\n  },\n  genOauthCb('google'),\n));\n\npassport.serializeUser((user, done) => done(null, user.id));\npassport.deserializeUser(async (id, done) => {\n  try {\n    const user = await User.findById(id);\n    return done(null, user);\n  } catch (err) {\n    return done(err);\n  }\n});\n","import express from 'express';\n\nimport authController from '../controllers/auth.controller';\nimport { catchAsyncError } from '../utils/helpers';\n\nconst isLoggedIn = (req, res, next) => {\n  if (req.isAuthenticated()) {\n    next();\n  } else {\n    res.redirect('/');\n  }\n};\n\nexport const authRouter = express.Router();\n\nauthRouter.get('/login', authController.loginForm);\nauthRouter.post('/login', authController.loginUser);\nauthRouter.get('/logout', isLoggedIn, authController.logoutUser);\nauthRouter.get('/profile', isLoggedIn, authController.profile);\nauthRouter.post('/profile', isLoggedIn, authController.preValidateProfile, authController.validateProfile, catchAsyncError(authController.updateProfile));\nauthRouter.post('/profile', authController.validateProfilePassword, catchAsyncError(authController.updateProfile));\nauthRouter.get('/link/local', isLoggedIn, authController.linkLocalForm);\nauthRouter.post('/link/local', isLoggedIn, authController.authLocal, catchAsyncError(authController.linkAccount));\nauthRouter.post('/unlink/:account', isLoggedIn, catchAsyncError(authController.unlinkAccount));\n\n[\n  {\n    provider: 'facebook',\n    config: {\n      scope: 'email',\n    },\n  },\n  { provider: 'twitter' },\n  {\n    provider: 'google',\n    config: {\n      scope: 'https://www.googleapis.com/auth/userinfo.profile',\n    },\n  },\n].forEach(({ provider, config }) => {\n  const { auth, authCb } = authController.genOauthLogin(provider, config);\n  authRouter.get(`/auth/${provider}`, auth);\n  authRouter.get(`/auth/${provider}/callback`, authCb, catchAsyncError(authController.linkAccount));\n  authRouter.get(`/link/${provider}`, isLoggedIn, auth);\n});\n","import express from 'express';\nimport { userRouter } from './user.router';\nimport { authRouter } from './auth.router';\n\nconst routes = express.Router();\n\nroutes.use('/', authRouter);\nroutes.use('/', userRouter);\n\nroutes.get('/', (req, res) => {\n  res.render('index', { title: 'Join' });\n});\n\nroutes.post('/chat', (req, res) => {\n  res.render('chat', { title: 'Chat' });\n});\n\n// handle mongoose validation errors\nroutes.use((err, req, res, next) => {\n  if (!err.errors) {\n    return next(err);\n  }\n\n  const validationErrors = Object.keys(err.errors);\n\n  if (validationErrors.length > 0) {\n    validationErrors.forEach(e => req.flash('error', err.errors[e].message));\n  }\n  return res.redirect('back');\n});\n\nroutes.use((err, req, res, next) => { // eslint-disable-line no-unused-vars\n  const status = err.status || 500;\n\n  res.status(status).render('error', {\n    status,\n    message: process.env.NODE_ENV === 'development' ? err : err.message,\n  });\n});\n\nexport default routes;\n","import express from 'express';\nimport { ensureLoggedIn } from 'connect-ensure-login';\nimport mongoose from 'mongoose';\nimport userController from '../controllers/user.controller';\n\nexport const userRouter = express.Router();\nconst User = mongoose.model('User');\n\nuserRouter.param('id', async (req, res, next, id) => {\n  try {\n    if (!mongoose.Types.ObjectId.isValid(id)) {\n      throw new Error('Invalid user id');\n    }\n    const user = await User.findById(id);\n    if (!user) {\n      throw new Error('No user found');\n    } else {\n      req.docFromId = user;\n      next();\n    }\n  } catch (err) {\n    next(err.message);\n  }\n});\n\nuserRouter.route('/signup')\n  .get(userController.signupForm)\n  .post(\n    userController.validateNewUser,\n    userController.validateHuman('signup'),\n    userController.createOne,\n    userController.sendConfirmEmail,\n  );\n\nuserRouter.route('/user/:id')\n  .get(ensureLoggedIn(), userController.getOne)\n  .put(userController.updateOne)\n  .delete(userController.deleteOne);\n\nuserRouter.route('/resend')\n  .get(userController.requestResend)\n  .post(userController.validateEmail, userController.validateHuman('confirmEmail'), userController.resend, userController.sendConfirmEmail);\nuserRouter.get('/confirm/:token', userController.confirmEmail);\n\nuserRouter.route('/forgot')\n  .get(userController.forgotPasswordForm)\n  .post(userController.validateEmail, userController.validateHuman('forgotPassword'), userController.forgotPassword, userController.sendResetEmail);\n\nuserRouter.route('/reset/:token')\n  .get(userController.validResetToken, userController.resetPasswordForm)\n  .post(\n    userController.validResetToken,\n    userController.validatePassword,\n    userController.resetPassword,\n    userController.sendPasswordUpdatedEmail,\n  );\n","/* eslint-disable no-console */\n\nimport express from 'express';\nimport http from 'http';\nimport socketIO from 'socket.io';\nimport { promisify } from 'es6-promisify';\n\nimport connect from './db';\nimport './passport';\nimport './mailer';\nimport genSocketEvents from './socketEvent';\nimport { default as globalMiddleware, session } from './middleware';\nimport routes from './routes';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIO(server);\nconnect().catch(err => console.error('Could not connect to DB', err.message));\n\napp.set('view engine', 'pug');\n\n/* without this, express incorrectly gets wrong header info because it thinks requests are coming\n   from nginx so for eg. req.protocol would be 'http' when it should be 'https' */\napp.set('trust proxy', true);\n\napp.use(globalMiddleware);\n\nio.use((socket, next) => {\n  session(socket.handshake, {}, next);\n});\n\nio.on('connection', (socket) => {\n  console.log('New user connected');\n  genSocketEvents(socket, io);\n});\n\n// convert callback based methods to use promises\napp.use((req, res, next) => {\n  req.login = promisify(req.login.bind(req));\n  next();\n});\n\n// pass variables to all templates\napp.use((req, res, next) => {\n  const flashes = req.flash();\n  res.locals.user = req.user;\n  res.locals.flashes = Object.keys(flashes).length > 0 ? flashes : undefined;\n  next();\n});\napp.use('/', routes);\n\nexport { server as default, io };\n","import mongoose from 'mongoose';\n\nimport isRealString from './utils/validation';\nimport { generateMessage, generateLocationMessage } from './utils/message';\nimport Users from './utils/users';\nimport Room from './models/room.model';\nimport Message from './models/message.model';\n\nconst users = Users.getInstance();\nconst User = mongoose.model('User');\n\n// update room list for people joining a room\nconst updateUserJoining = (io) => {\n  io.emit('updateRoomList', { rooms: users.getRoomList() });\n};\n\nconst joinRoom = (socket, io) => socket.on('join', async (params, callback) => {\n  if (!isRealString(params.room)) {\n    return callback('Room name required!');\n  }\n\n  const roomName = params.room.trim().toLowerCase();\n  socket.join(roomName);\n\n  const { passport } = socket.handshake.session;\n  let name, mongoUserId;\n  if (passport && passport.user) {\n    try {\n      const user = await User.findById(passport.user);\n      name = user.username;\n      mongoUserId = user.id;\n    } catch (err) {\n      return callback('Could not retrieve user information');\n    }\n  } else {\n    const objectId = new mongoose.Types.ObjectId;\n    name = `guest-${objectId.toString().slice(-4)}`;\n    await User.create({ username: name, _id: objectId });\n    mongoUserId = objectId.toString();\n  }\n\n  try {\n    const room = await Room.findOne({ name: roomName });\n\n    if (!room) {\n      await Room.create({ name: roomName });\n    }\n  } catch (err) {\n    return callback('Could not create room');\n  }\n\n  let messages;\n  try {\n    messages = await Message\n      .find({ to: roomName }, { _id: 0 }, { sort: { createdAt: 1 }})\n      .populate('from', { username: 1, _id: 0 });\n  } catch (err) {\n    return callback('Could not get message history');\n  }\n\n  users.removeUser(socket.id);\n  users.addUser(socket.id, name, roomName, mongoUserId);\n  io.to(roomName).emit('updateUserList', users.getUserList(roomName));\n  socket.emit('newMessage', generateMessage('Admin', `Welcome to the room ${roomName}!`));\n  socket.broadcast.to(roomName).emit('newMessage', generateMessage('Admin', `${name} joined the chat`));\n\n  updateUserJoining(io);\n  return callback(null, messages);\n});\n\nconst createMessage = (socket, io) => socket.on('createMessage', async (message, callback) => {\n  const user = users.getUser({ id: socket.id });\n\n  if (user && isRealString(message.text)) {\n    try {\n      await Message.create({ from: user.mongoId, to: user.room, content: message.text });\n    } catch (err) {\n      return callback('Error persisting message to db');\n    }\n\n    io.to(user.room).emit('newMessage', generateMessage(user.name, message.text));\n  }\n  callback();\n});\n\nconst createLocationMessage = (socket, io) => socket.on('createLocationMessage', (coords) => {\n  const user = users.getUser({ id: socket.id });\n\n  if (user) {\n    io.to(user.room).emit('newLocationMessage', generateLocationMessage(user.name, coords.latitude, coords.longitude));\n  }\n});\n\nconst disconnect = (socket, io) => socket.on('disconnect', () => {\n  const user = users.removeUser(socket.id);\n\n  io.to(user.room).emit('updateUserList', users.getUserList(user.room));\n  io.to(user.room).emit('newMessage', generateMessage('Admin', `${user.name} has left`));\n  updateUserJoining(io);\n});\n\nconst getRoomList = socket => socket.on('getRoomList', (_, callback) => {\n  callback({ rooms: users.getRoomList() });\n});\n\nexport default (socket, io) => ({\n  joinRoom: joinRoom(socket, io),\n  createMessage: createMessage(socket, io),\n  createLocationMessage: createLocationMessage(socket, io),\n  disconnect: disconnect(socket, io),\n  getRoomList: getRoomList(socket, io),\n});\n","export const catchAsyncError = fn => (req, res, next) => fn(req, res, next).catch(next);\n","import moment from 'moment';\n\nexport const generateMessage = (from, text) => ({\n  from,\n  text,\n  createdAt: moment().valueOf(),\n});\n\nexport const generateLocationMessage = (from, latitude, longitude) => ({\n  from,\n  url: `https://www.google.com/maps?q=${latitude},${longitude}`,\n  createdAt: moment().valueOf(),\n});\n","class UsersClass {\n  constructor() {\n    this.users = [];\n  }\n\n  addUser(id, name, room, mongoId) {\n    const user = { id, name, room, mongoId };\n    this.users.push(user);\n    return user;\n  }\n\n  removeUser(id) {\n    const userToRemove = Object.assign({}, this.getUser({ id }));\n\n    if (userToRemove) {\n      this.users = this.users.filter(user => user.id !== userToRemove.id);\n    }\n\n    return userToRemove;\n  }\n\n  getUser({ id, name }) {\n    return this.users.find(user => user.id === id || user.name === name);\n  }\n\n  getUserList(room) {\n    const users = this.users.filter(user => user.room === room);\n    const namesArray = users.map(user => user.name);\n\n    return namesArray;\n  }\n\n  getRoomList() {\n    const rooms = new Set(this.users.map(user => user.room));\n    return [...rooms];\n  }\n}\n\nconst Users = (() => {\n  let instance;\n\n  const createInstance = () => new UsersClass();\n\n  return {\n    getInstance() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    },\n  };\n})();\n\nexport default Users;\nexport { UsersClass };\n","const isRealString = string => typeof string === 'string' && string.trim().length > 0;\n\nexport default isRealString;\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAEA;;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/GA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}