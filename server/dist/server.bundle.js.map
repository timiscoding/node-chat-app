{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"mongoose\"","webpack:///external \"passport\"","webpack:///external \"express\"","webpack:///external \"lodash\"","webpack:///external \"path\"","webpack:///external \"crypto\"","webpack:///external \"express-validator/check\"","webpack:///external \"express-session\"","webpack:///external \"body-parser\"","webpack:///external \"moment\"","webpack:///external \"bcrypt\"","webpack:///external \"request-promise\"","webpack:///external \"connect-ensure-login\"","webpack:///external \"connect-flash\"","webpack:///external \"email-templates\"","webpack:///external \"passport-google-oauth\"","webpack:///external \"passport-twitter\"","webpack:///external \"passport-facebook\"","webpack:///external \"passport-local\"","webpack:///external \"mongoose-beautiful-unique-validation\"","webpack:///external \"validator/lib/isEmail\"","webpack:///external \"es6-promisify\"","webpack:///external \"socket.io\"","webpack:///external \"http\"","webpack:///./server/models/user.model.js","webpack:///./server/models/emailVerifyToken.model.js","webpack:///./server/db.js","webpack:///./server/passport.js","webpack:///./server/mailer.js","webpack:///./server/utils/validation.js","webpack:///./server/utils/message.js","webpack:///./server/utils/users.js","webpack:///./server/models/room.model.js","webpack:///./server/models/message.model.js","webpack:///./server/socketEvent.js","webpack:///./server/middleware.js","webpack:///./server/controllers/userValidator.js","webpack:///./server/utils/helpers.js","webpack:///./server/controllers/user.controller.js","webpack:///./server/routes/user.router.js","webpack:///./server/controllers/auth.controller.js","webpack:///./server/routes/auth.router.js","webpack:///./server/routes/index.js","webpack:///./server/server.js","webpack:///./server/index.js","webpack:///external \"connect-mongo\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","userSchema","external_mongoose_default","a","Schema","username","type","String","required","unique","sparse","lowercase","trim","match","local","email","validate","isEmail_default","password","minlength","isVerified","Boolean","default","facebook","id","token","displayName","twitter","google","passwordResetToken","passwordResetExpires","Date","methods","isValidPassword","external_bcrypt_default","compare","this","types","accountsTotal","keys","toObject","reduce","total","f","includes","statics","hashPassword","plaintextPassword","Error","hash","genUniqueUsername","async","snakeCase","toLowerCase","replace","usernameRegex","RegExp","usernames","find","newUsername","external_lodash_default","length","plugin","external_mongoose_beautiful_unique_validation_default","model","emailVerifyTokenSchema","user","Types","ObjectId","ref","createdAt","expires","now","external_crypto_default","randomBytes","toString","findOneOrCreate","userId","Token","findOne","createToken","db","connect","process","env","MONGODB_URI","User","external_passport_default","use","external_passport_local_default","usernameField","passReqToCallback","req","done","local.email","message","err","getEmail","profile","emails","createAccount","provider","[object Object]","genOauthCb","accessToken","refreshTokenOrSecret","save","firstLogin","external_passport_facebook_default","clientID","FACEBOOK_APP_ID","clientSecret","FACEBOOK_APP_SECRET","callbackURL","DOMAIN","profileFields","external_passport_twitter_default","consumerKey","TWITTER_CONSUMER_KEY","consumerSecret","TWITTER_CONSUMER_SECRET","external_passport_google_oauth_","GOOGLE_APP_ID","GOOGLE_APP_SECRET","serializeUser","deserializeUser","findById","mailer","external_email_templates_default","from","transport","port","MAILER_PORT","host","MAILER_HOST","auth","MAILER_USERNAME","pass","MAILER_PASSWORD","juice","juiceResources","webResources","relativeTo","external_path_default","join","__dirname","views","root","validation","string","generateMessage","text","external_moment_default","valueOf","users","instance","createInstance","room","mongoId","push","userToRemove","assign","getUser","filter","map","Set","getInstance","roomSchema","minLength","room_model","messageSchema","to","index","content","message_model","socketEvent_users","socketEvent_User","updateUserJoining","io","emit","rooms","getRoomList","createLocationMessage","socket","on","coords","latitude","longitude","url","generateLocationMessage","socketEvent","joinRoom","params","callback","roomName","passport","handshake","session","mongoUserId","messages","objectId","slice","_id","sort","populate","removeUser","addUser","getUserList","broadcast","createMessage","disconnect","_","sessionConfig","secret","SESSION_SECRET","resave","saveUninitialized","MongoStore","external_express_session_default","store","mongooseConnection","connection","autoRemove","middleware","external_express_default","static","external_body_parser_default","json","urlencoded","extended","initialize","external_connect_flash_default","userValidator_userSchema","in","isLength","errorMessage","options","min","custom","test","isEmail","normalizeEmail","all_lowercase","gmail_convert_googlemaildotcom","gmail_remove_dots","gmail_remove_subaddress","password-confirm","body","userValidatorSchema","fields","pick","validateUserForm","schema","view","isOptional","check_","chain","optional","res","next","errors","formatWith","msg","isEmpty","flash","array","onlyFirstError","render","flashes","recaptchaKey","G_RECAPTCHA_SITE_KEY","redirect","catchAsyncError","fn","catch","user_controller_User","EmailVerifyToken","validateNewUser","validateEmail","validatePassword","user_controller","createOne","emailToken","getOne","send","updateOne","docFromId","deleteOne","signupForm","confirmEmail","findOneAndRemove","login","requestResend","resend","sendConfirmEmail","template","locals","confirmURL","protocol","hostname","forgotPasswordForm","forgotPassword","sendResetEmail","resetURL","resetPasswordForm","resetPassword","undefined","validResetToken","$gt","sendPasswordUpdatedEmail","validateHuman","failureView","method","uri","formData","G_RECAPTCHA_SECRET","response","external_request_promise_default","success","userRouter","Router","user_router_User","param","isValid","route","post","external_connect_ensure_login_","put","delete","auth_controller_User","loginUser","authenticate","successReturnToOrRedirect","failureRedirect","failureFlash","successFlash","authLocal","authorize","auth_controller_validateEmail","validateUsername","auth_controller","loginForm","logoutUser","logout","genOauthLogin","config","scope","routes","info","error","linkedAccounts","entries","all","acc","linkable","linkAccount","account","accountObj","doc","ret","newRet","__v","remove","unlinkAccount","status","linkLocalForm","updateProfile","preValidateProfile","isLoggedIn","isAuthenticated","authRouter","forEach","authCb","routes_routes","title","validationErrors","e","server_routes","app","server","external_http_default","createServer","server_io","external_socket_io_default","console","set","log","external_es6_promisify_","PORT","listen"],"mappings":"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","file":"server.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 26);\n","module.exports = require(\"mongoose\");","module.exports = require(\"passport\");","module.exports = require(\"express\");","module.exports = require(\"lodash\");","module.exports = require(\"path\");","module.exports = require(\"crypto\");","module.exports = require(\"express-validator/check\");","module.exports = require(\"express-session\");","module.exports = require(\"body-parser\");","module.exports = require(\"moment\");","module.exports = require(\"bcrypt\");","module.exports = require(\"request-promise\");","module.exports = require(\"connect-ensure-login\");","module.exports = require(\"connect-flash\");","module.exports = require(\"email-templates\");","module.exports = require(\"passport-google-oauth\");","module.exports = require(\"passport-twitter\");","module.exports = require(\"passport-facebook\");","module.exports = require(\"passport-local\");","module.exports = require(\"mongoose-beautiful-unique-validation\");","module.exports = require(\"validator/lib/isEmail\");","module.exports = require(\"es6-promisify\");","module.exports = require(\"socket.io\");","module.exports = require(\"http\");","import mongoose from 'mongoose';\nimport bcrypt from 'bcrypt';\nimport isEmail from 'validator/lib/isEmail';\nimport beautifyUnique from 'mongoose-beautiful-unique-validation';\nimport _ from 'lodash';\n\nconst userSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: 'Username is required',\n    unique: 'Username already taken',\n    sparse: true,\n    lowercase: true,\n    trim: true,\n    match: [/^[\\w-]+$/, \"Username must contain alphanumeric, '-', '_' characters only\"],\n  },\n  local: {\n    email: {\n      type: String,\n      unique: 'An account with email {VALUE} already exists',\n      sparse: true, // allows us to add documents without unique fields\n      trim: true,\n      lowercase: true,\n      validate: [isEmail, 'Email is not valid'],\n    },\n    password: {\n      type: String,\n      trim: true,\n      minlength: 5,\n    },\n    isVerified: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  facebook: {\n    id: String,\n    token: String,\n    displayName: String,\n    email: String,\n  },\n  twitter: {\n    id: String,\n    token: String,\n    displayName: String,\n    username: String,\n  },\n  google: {\n    id: String,\n    token: String,\n    displayName: String,\n    email: String,\n  },\n  passwordResetToken: String,\n  passwordResetExpires: Date,\n});\n\nuserSchema.methods.isValidPassword = function isValidPassword(password) {\n  return bcrypt.compare(password, this.local.password);\n};\n\nconst types = ['twitter', 'google', 'facebook', 'local'];\nuserSchema.methods.accountsTotal = function accountsTotal() {\n  return Object.keys(this.toObject()).reduce((total, f) => {\n    if (types.includes(f)) {\n      if (f === 'local' || (f !== 'local' && this[f].token)) {\n        return total + 1;\n      }\n    }\n    return total;\n  }, 0);\n};\n\nuserSchema.statics.hashPassword = function hashPassword(plaintextPassword) {\n  if (!plaintextPassword) {\n    throw new Error('Password cannot be blank');\n  }\n  return bcrypt.hash(plaintextPassword, 12);\n};\n\nuserSchema.statics.genUniqueUsername = async function genUniqueUsername(name = 'anon') {\n  const snakeCase = name.toLowerCase().replace(/ /g, '_');\n  const usernameRegex = new RegExp(`^${snakeCase}\\d*$`);\n  const usernames = await this.find({ username: usernameRegex }, 'username');\n  let newUsername = snakeCase;\n  // find the first unique username with format username<incrementing number>\n  for (let i = 0; _.find(usernames, { username: newUsername }); i += 1) {\n    newUsername = snakeCase + (usernames.length + i);\n  }\n  return newUsername;\n};\n\n// if client tries creating a duplicate on a unique field, it will produce a low level\n// mongo db error. This plugin transforms that error into a mongoose validation error\n// that exists in an 'errors' object\nuserSchema.plugin(beautifyUnique);\n\nexport default mongoose.model('User', userSchema);\n","import mongoose from 'mongoose';\nimport crypto from 'crypto';\n\nconst emailVerifyTokenSchema = new mongoose.Schema({\n  user: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n  },\n  createdAt: {\n    type: Date,\n    expires: '5 min',\n    default: Date.now,\n  },\n  token: {\n    type: String,\n    required: true,\n  },\n});\n\nconst token = () => crypto.randomBytes(20).toString('hex');\n\nemailVerifyTokenSchema.statics.findOneOrCreate = async function findOneOrCreate(userId) {\n  const Token = this;\n  if (userId) {\n    const foundToken = await Token.findOne({ user: userId });\n\n    return foundToken || Token.create({\n      user: userId,\n      token: token(),\n    });\n  }\n\n  return new Error('User id not given');\n};\n\nemailVerifyTokenSchema.statics.createToken = async function createToken(userId) {\n  const Token = this;\n  return Token.create({\n    user: userId,\n    token: token(),\n  });\n};\n\nexport default mongoose.model('EmailVerifyToken', emailVerifyTokenSchema);\n","import mongoose from 'mongoose';\nimport './models';\n\nconst connect = async () => mongoose.connect(process.env.MONGODB_URI);\n\nexport default connect;\n\n","import passport from 'passport';\nimport LocalStrategy from 'passport-local';\nimport FacebookStrategy from 'passport-facebook';\nimport TwitterStrategy from 'passport-twitter';\nimport { OAuth2Strategy as GoogleStrategy } from 'passport-google-oauth';\nimport mongoose from 'mongoose';\nimport _ from 'lodash';\n\nconst User = mongoose.model('User');\n\npassport.use(new LocalStrategy(\n  { usernameField: 'email', passReqToCallback: true },\n  async (req, email, password, done) => {\n    try {\n      const user = await User.findOne({ 'local.email': email });\n      if (!user) {\n        return done(null, false, { message: 'Email or password is invalid' });\n      }\n\n      const isValidPassword = await user.isValidPassword(password);\n      if (!isValidPassword) {\n        return done(null, false, { message: 'Email or password is invalid' });\n      }\n\n      if (!user.local.isVerified) {\n        return done(null, false, { message: 'The email has not been verified for this account. <a href=\"/resend\">Resend email confirmation</a>' });\n      }\n\n      /* user is either\n         a) already logged in via oauth and trying to link this local account so the user will be\n         injected into req.account\n         b) logging into their local account so the user will be injected into req.user */\n      return done(null, user);\n    } catch (err) {\n      return done(err, null, { message: 'Could not authenticate. Please try again' });\n    }\n  },\n));\n\nconst getEmail = profile => profile.emails && profile.emails.length && profile.emails[0].value;\nconst createAccount = async (provider, token, profile) => User.create({\n  [provider]: {\n    id: profile.id,\n    displayName: profile.displayName,\n    token,\n    email: getEmail(profile),\n  },\n  username: await User.genUniqueUsername(profile.username || profile.displayName),\n});\n\nconst genOauthCb = provider => async (req, accessToken, refreshTokenOrSecret, profile, done) => {\n  try {\n    let user = await User.findOne({ [`${provider}.id`]: profile.id });\n    if (!req.user) { // not already logged in\n      if (user) {\n        if (!user[provider].token) { // user unlinked this account but has logged in later\n          user[provider] = {\n            id: profile.id,\n            displayName: profile.displayName,\n            token: accessToken,\n            email: getEmail(profile),\n          };\n          user = await user.save();\n        }\n        return done(null, user);\n      }\n\n      user = await createAccount(provider, accessToken, profile);\n\n      /* when a user logs in for the first time, we need a way to inform the authController so that\n         they can send them to a profile page to let them change their username if they want.\n         firstLogin is my own custom prop that will be sent to the custom callback whenever\n         passport.auth(enticate|orize)() is called\n         */\n      return done(null, user, { firstLogin: true });\n    }\n    /* user already logged in and trying to link another account  */\n\n    /* if user tries to link an already linked account, just return the original user */\n    if (user) {\n      /* user previously unlinked account and now wants to relink it.\n        we must update the token and other profile info */\n      if (!user[provider].token) {\n        user = await createAccount(provider, accessToken, profile);\n      }\n      return done(null, user);\n    }\n\n    /* user linking an account they have never authorised before so lets create it first */\n    user = await createAccount(provider, accessToken, profile);\n\n    return done(null, user);\n  } catch (err) {\n    return done(err, false, { message: 'Could not authenticate. Please try again' });\n  }\n};\n\npassport.use(new FacebookStrategy(\n  {\n    clientID: process.env.FACEBOOK_APP_ID,\n    clientSecret: process.env.FACEBOOK_APP_SECRET,\n    callbackURL: `${process.env.DOMAIN}/auth/facebook/callback`,\n    profileFields: ['email', 'displayName'],\n    passReqToCallback: true,\n  },\n  genOauthCb('facebook'),\n));\n\npassport.use(new TwitterStrategy(\n  {\n    consumerKey: process.env.TWITTER_CONSUMER_KEY,\n    consumerSecret: process.env.TWITTER_CONSUMER_SECRET,\n    callbackURL: `${process.env.DOMAIN}/auth/twitter/callback`,\n    passReqToCallback: true,\n  },\n  genOauthCb('twitter'),\n));\n\npassport.use(new GoogleStrategy(\n  {\n    clientID: process.env.GOOGLE_APP_ID,\n    clientSecret: process.env.GOOGLE_APP_SECRET,\n    callbackURL: `${process.env.DOMAIN}/auth/google/callback`,\n    passReqToCallback: true,\n  },\n  genOauthCb('google'),\n));\n\npassport.serializeUser((user, done) => done(null, user.id));\npassport.deserializeUser(async (id, done) => {\n  try {\n    const user = await User.findById(id);\n    return done(null, user);\n  } catch (err) {\n    return done(err);\n  }\n});\n","import Email from 'email-templates';\nimport path from 'path';\n\nconst email = new Email({\n  message: {\n    from: 'no-reply@timiscoding.me',\n  },\n  // send: true, // uncomment to send emails in dev env\n  transport: {\n    port: process.env.MAILER_PORT,\n    host: process.env.MAILER_HOST,\n    auth: {\n      user: process.env.MAILER_USERNAME,\n      pass: process.env.MAILER_PASSWORD,\n    },\n  },\n  juice: true,\n  juiceResources: {\n    webResources: {\n      relativeTo: path.join(__dirname, '../../views/emails/build'),\n    },\n  },\n  views: {\n    root: path.join(__dirname, '../../views/emails'),\n  },\n});\n\nexport default email;\n","const isRealString = string => typeof string === 'string' && string.trim().length > 0;\n\nexport default isRealString;\n","import moment from 'moment';\n\nexport const generateMessage = (from, text) => ({\n  from,\n  text,\n  createdAt: moment().valueOf(),\n});\n\nexport const generateLocationMessage = (from, latitude, longitude) => ({\n  from,\n  url: `https://www.google.com/maps?q=${latitude},${longitude}`,\n  createdAt: moment().valueOf(),\n});\n","class UsersClass {\n  constructor() {\n    this.users = [];\n  }\n\n  addUser(id, name, room, mongoId) {\n    const user = { id, name, room, mongoId };\n    this.users.push(user);\n    return user;\n  }\n\n  removeUser(id) {\n    const userToRemove = Object.assign({}, this.getUser({ id }));\n\n    if (userToRemove) {\n      this.users = this.users.filter(user => user.id !== userToRemove.id);\n    }\n\n    return userToRemove;\n  }\n\n  getUser({ id, name }) {\n    return this.users.find(user => user.id === id || user.name === name);\n  }\n\n  getUserList(room) {\n    const users = this.users.filter(user => user.room === room);\n    const namesArray = users.map(user => user.name);\n\n    return namesArray;\n  }\n\n  getRoomList() {\n    const rooms = new Set(this.users.map(user => user.room));\n    return [...rooms];\n  }\n}\n\nconst Users = (() => {\n  let instance;\n\n  const createInstance = () => new UsersClass();\n\n  return {\n    getInstance() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    },\n  };\n})();\n\nexport default Users;\nexport { UsersClass };\n","import mongoose from 'mongoose';\n\nconst roomSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: true,\n    minLength: 1,\n    trim: true,\n  },\n});\n\nexport default mongoose.model('Room', roomSchema);\n","import mongoose from 'mongoose';\n\nconst messageSchema = new mongoose.Schema({\n  createdAt: {\n    type: Date,\n    default: Date.now,\n  },\n  to: {\n    type: String,\n    index: true,\n    required: true,\n  },\n  from: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n  },\n  content: {\n    type: String,\n    trim: true,\n    minLength: 1,\n    required: true,\n  },\n});\n\nexport default mongoose.model('Message', messageSchema);\n","import mongoose from 'mongoose';\n\nimport isRealString from './utils/validation';\nimport { generateMessage, generateLocationMessage } from './utils/message';\nimport Users from './utils/users';\nimport Room from './models/room.model';\nimport Message from './models/message.model';\n\nconst users = Users.getInstance();\nconst User = mongoose.model('User');\n\n// update room list for people joining a room\nconst updateUserJoining = (io) => {\n  io.emit('updateRoomList', { rooms: users.getRoomList() });\n};\n\nconst joinRoom = (socket, io) => socket.on('join', async (params, callback) => {\n  if (!isRealString(params.room)) {\n    return callback('Room name required!');\n  }\n\n  const roomName = params.room.trim().toLowerCase();\n  socket.join(roomName);\n\n  const { passport } = socket.handshake.session;\n  let name, mongoUserId;\n  if (passport && passport.user) {\n    try {\n      const user = await User.findById(passport.user);\n      name = user.username;\n      mongoUserId = user.id;\n    } catch (err) {\n      return callback('Could not retrieve user information');\n    }\n  } else {\n    const objectId = new mongoose.Types.ObjectId;\n    name = `guest-${objectId.toString().slice(-4)}`;\n    await User.create({ username: name, _id: objectId });\n    mongoUserId = objectId.toString();\n  }\n\n  try {\n    const room = await Room.findOne({ name: roomName });\n\n    if (!room) {\n      await Room.create({ name: roomName });\n    }\n  } catch (err) {\n    return callback('Could not create room');\n  }\n\n  let messages;\n  try {\n    messages = await Message\n      .find({ to: roomName }, { _id: 0 }, { sort: { createdAt: 1 }})\n      .populate('from', { username: 1, _id: 0 });\n  } catch (err) {\n    return callback('Could not get message history');\n  }\n\n  users.removeUser(socket.id);\n  users.addUser(socket.id, name, roomName, mongoUserId);\n  io.to(roomName).emit('updateUserList', users.getUserList(roomName));\n  socket.broadcast.to(roomName).emit('newMessage', generateMessage('Admin', `${name} joined the chat`));\n\n  updateUserJoining(io);\n  return callback(null, messages);\n});\n\nconst createMessage = (socket, io) => socket.on('createMessage', async (message, callback) => {\n  const user = users.getUser({ id: socket.id });\n\n  if (user && isRealString(message.text)) {\n    try {\n      await Message.create({ from: user.mongoId, to: user.room, content: message.text });\n    } catch (err) {\n      return callback('Error persisting message to db');\n    }\n\n    io.to(user.room).emit('newMessage', generateMessage(user.name, message.text));\n  }\n  callback();\n});\n\nconst createLocationMessage = (socket, io) => socket.on('createLocationMessage', (coords) => {\n  const user = users.getUser({ id: socket.id });\n\n  if (user) {\n    io.to(user.room).emit('newLocationMessage', generateLocationMessage(user.name, coords.latitude, coords.longitude));\n  }\n});\n\nconst disconnect = (socket, io) => socket.on('disconnect', () => {\n  const user = users.removeUser(socket.id);\n\n  io.to(user.room).emit('updateUserList', users.getUserList(user.room));\n  io.to(user.room).emit('newMessage', generateMessage('Admin', `${user.name} has left`));\n  updateUserJoining(io);\n});\n\nconst getRoomList = socket => socket.on('getRoomList', (_, callback) => {\n  callback({ rooms: users.getRoomList() });\n});\n\nexport default (socket, io) => ({\n  joinRoom: joinRoom(socket, io),\n  createMessage: createMessage(socket, io),\n  createLocationMessage: createLocationMessage(socket, io),\n  disconnect: disconnect(socket, io),\n  getRoomList: getRoomList(socket, io),\n});\n","import express from 'express';\nimport path from 'path';\nimport bodyParser from 'body-parser';\nimport passport from 'passport';\nimport Session from 'express-session';\nimport flash from 'connect-flash';\nimport mongoose from 'mongoose';\n\nconst sessionConfig = {\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n};\n\nif (process.env.NODE_ENV === 'production') {\n  const MongoStore = require('connect-mongo')(Session);\n  sessionConfig.store = new MongoStore({\n    mongooseConnection: mongoose.connection,\n    autoRemove: 'native',\n  });\n} else if (process.env.NODE_ENV === 'development') {\n  const FileStore = require('session-file-store')(Session);\n  sessionConfig.store = new FileStore();\n}\n\nexport const session = Session(sessionConfig);\n\nexport default [\n  express.static(path.join(__dirname, '../../public')),\n  bodyParser.json(),\n  bodyParser.urlencoded({ extended: true }),\n  session,\n  passport.initialize(),\n  passport.session(),\n  flash(),\n];\n","import _ from 'lodash';\nimport { validationResult, checkSchema } from 'express-validator/check';\n\nconst userSchema = {\n  username: {\n    in: 'body',\n    isLength: {\n      errorMessage: 'Username must not be empty',\n      options: { min: 1 },\n    },\n    custom: {\n      options: (value) => {\n        const guestRe = /^guest-\\w+$/i;\n        const validUserRe = /^[\\w-]+$/;\n        if (!validUserRe.test(value)) {\n          throw new Error(\"Username must be letters, numbers, '_', ' -' only\");\n        } else if (guestRe.test(value)) {\n          throw new Error(\"Usernames beginning with 'guest-' are reserved for unregistered users\");\n        }\n        return true;\n      },\n    },\n    trim: true,\n  },\n  email: {\n    in: 'body',\n    isEmail: {\n      errorMessage: 'Email address is not valid',\n    },\n    trim: true,\n    normalizeEmail: {\n      options: {\n        all_lowercase: true,\n        gmail_convert_googlemaildotcom: true,\n        gmail_remove_dots: true,\n        gmail_remove_subaddress: true,\n      },\n    },\n  },\n  password: {\n    in: 'body',\n    isLength: {\n      errorMessage: 'Password must be at least 5 characters long',\n      options: { min: 5 },\n    },\n    trim: true,\n  },\n  'password-confirm': {\n    in: 'body',\n    custom: {\n      options: (value, { req }) => {\n        if (req.body.password !== value) {\n          throw new Error('Password confirmation does not match password field');\n        }\n        return true;\n      },\n    },\n  },\n};\n\nconst userValidatorSchema = (...fields) =>\n  (fields.length ? _.pick(userSchema, fields) : userSchema);\n\nconst validateUserForm = (schema, view, isOptional) => [\n  isOptional ? checkSchema(schema).map(chain => chain.optional()) : checkSchema(schema),\n  (req, res, next) => {\n    const errors = validationResult(req).formatWith(({ msg }) => msg);\n    if (errors.isEmpty()) {\n      return next();\n    }\n\n    req.flash('error', errors.array({ onlyFirstError: true }));\n\n    if (view) {\n      return res.render(view, {\n        body: req.body,\n        flashes: req.flash(),\n        recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY,\n      });\n    }\n    return res.redirect('back');\n  },\n];\n\nexport { userValidatorSchema, validateUserForm };\n","export const catchAsyncError = fn => (req, res, next) => fn(req, res, next).catch(next);\n","import mongoose from 'mongoose';\nimport crypto from 'crypto';\nimport rp from 'request-promise';\n\nimport { userValidatorSchema, validateUserForm } from './userValidator';\nimport { catchAsyncError } from '../utils/helpers';\nimport mailer from '../mailer';\n\nconst User = mongoose.model('User');\nconst EmailVerifyToken = mongoose.model('EmailVerifyToken');\n\nconst signupForm = (req, res) => {\n  res.render('signup', { recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY });\n};\n\nconst validateNewUser = validateUserForm(userValidatorSchema(), 'signup');\n\nconst validateHuman = failureView => async (req, res, next) => {\n  const options = {\n    method: 'POST',\n    uri: 'https://www.google.com/recaptcha/api/siteverify',\n    formData: {\n      secret: process.env.G_RECAPTCHA_SECRET,\n      response: req.body['g-recaptcha-response'],\n    },\n    json: true,\n  };\n\n  try {\n    const captchaRes = await rp(options);\n\n    if (captchaRes.success) {\n      return next();\n    }\n  } catch (err) {\n    return next(err);\n  }\n\n  req.flash('error', 'reCaptcha failed. Please try again');\n  return res.render(failureView, {\n    body: req.body,\n    flashes: req.flash(),\n    recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY,\n  });\n};\n\nconst createOne = async (req, res, next) => {\n  const { email, password, username } = req.body;\n  try {\n    const user = await User.create({\n      local: { email, password: await User.hashPassword(password) },\n      username,\n    });\n\n    req.emailToken = await EmailVerifyToken.createToken(user.id);\n    next();\n  } catch (err) {\n    if (err.errors) {\n      const keys = Object.keys(err.errors);\n      const flashes = keys.map(key => err.errors[key].message);\n      req.flash('error', flashes);\n      res.render('signup', {\n        body: { username, email },\n        flashes: req.flash(),\n        recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY,\n      });\n    } else {\n      next(err);\n    }\n  }\n};\n\nconst sendConfirmEmail = (req, res) => {\n  const { email, username } = req.body;\n\n  mailer.send({\n    template: 'verifyEmail',\n    message: {\n      to: email,\n    },\n    locals: {\n      name: username,\n      confirmURL: `${req.protocol}://${req.hostname}/confirm/${req.emailToken.token}`,\n    },\n  });\n\n  req.flash('info', `An email has been sent to ${email}. Please confirm your email to complete sign up.`);\n  res.redirect('/');\n};\n\nconst confirmEmail = async (req, res) => {\n  const token = await EmailVerifyToken.findOneAndRemove({ token: req.params.token }).populate('user');\n  if (!token) {\n    req.flash('error', `Email verification invalid. Either the link does not match the one provided\n      in the email or the link may have expired. <a href=\"/resend\">Resend email confirmation</a>`);\n    return res.redirect('/');\n  }\n\n  const { user } = token;\n  user.local.isVerified = true;\n  await user.save();\n  await req.login(user);\n  req.flash('success', 'Your email has been confirmed. You are now logged in');\n  return res.redirect('/');\n};\n\n/* Resend confirmation email */\n\nconst requestResend = (req, res) => {\n  res.render('confirmEmail', { recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY });\n};\n\nconst validateEmail = validateUserForm(userValidatorSchema('email'), 'confirmEmail');\n\nconst resend = async (req, res, next) => {\n  const user = await User.findOne({ 'local.email': req.body.email });\n\n  if (!user || !user.local) {\n    req.flash('info', 'An account with this email does not exist');\n    return res.render('confirmEmail', { body: req.body, flashes: req.flash() });\n  }\n\n  if (user.local && user.local.isVerified) {\n    req.flash('info', 'The email for this account is already confirmed');\n    return res.redirect('/');\n  }\n\n  req.emailToken = await EmailVerifyToken.findOneOrCreate(user.id);\n  req.body.username = user.username;\n  return next();\n};\n\n/* Reset password */\n\nconst forgotPasswordForm = (req, res) => {\n  res.render('forgotPassword', { recaptchaKey: process.env.G_RECAPTCHA_SITE_KEY });\n};\n\nconst forgotPassword = async (req, res, next) => {\n  const user = await User.findOne({ 'local.email': req.body.email });\n\n  if (!user || !user.local) {\n    req.flash('info', 'An account with this email does not exist');\n    return res.render('forgotPassword', { body: req.body, flashes: req.flash() });\n  }\n\n  user.passwordResetToken = crypto.randomBytes(20).toString('hex');\n  user.passwordResetExpires = Date.now() + 3600000;\n  await user.save();\n  req.emailToken = user.passwordResetToken;\n  req.body.username = user.username;\n  return next();\n};\n\nconst sendResetEmail = (req, res) => {\n  const { email, username } = req.body;\n\n  mailer.send({\n    template: 'resetPassword',\n    message: {\n      to: email,\n    },\n    locals: {\n      name: username,\n      resetURL: `${req.protocol}://${req.hostname}/reset/${req.emailToken}`,\n    },\n  });\n\n  req.flash('info', `An email has been sent to ${email} with instructions to reset your password.`);\n  res.redirect('/');\n};\n\nconst validResetToken = async (req, res, next) => {\n  const user = await User.findOne({\n    passwordResetToken: req.params.token,\n    passwordResetExpires: { $gt: Date.now() },\n  });\n  if (!user) {\n    req.flash('error', 'This password reset is invalid or expired. Please request a new one');\n    return res.redirect('/forgot');\n  }\n  req.user = user;\n  return next();\n};\n\nconst resetPasswordForm = async (req, res) => {\n  res.render('resetPassword');\n};\n\nconst validatePassword = validateUserForm(userValidatorSchema('password', 'password-confirm'), 'resetPassword');\n\nconst resetPassword = async (req, res, next) => {\n  const { user } = req;\n\n  user.local.password = await User.hashPassword(req.body.password);\n  user.passwordResetExpires = undefined;\n  user.passwordResetToken = undefined;\n  await user.save();\n  await req.login(user);\n  next();\n};\n\nconst sendPasswordUpdatedEmail = async (req, res) => {\n  const { local: { email }, username } = req.user;\n\n  mailer.send({\n    template: 'updatedPassword',\n    message: {\n      to: email,\n    },\n    locals: {\n      name: username,\n    },\n  });\n\n  req.flash('success', 'Password has been updated');\n  res.redirect('/');\n};\n\nconst getOne = async (req, res) => {\n  const user = await User.findById(req.user.id);\n  res.send(`get user\\n ${user}`);\n};\n\nconst updateOne = (req, res) => {\n  res.send(`update user\\n ${req.docFromId}`);\n};\n\nconst deleteOne = (req, res) => {\n  res.send(`delete user\\n ${req.docFromId}`);\n};\n\nexport default {\n  createOne: catchAsyncError(createOne),\n  getOne: catchAsyncError(getOne),\n  updateOne: catchAsyncError(updateOne),\n  deleteOne: catchAsyncError(deleteOne),\n  signupForm,\n  validateNewUser,\n  confirmEmail: catchAsyncError(confirmEmail),\n  requestResend,\n  validateEmail,\n  resend,\n  sendConfirmEmail,\n  forgotPasswordForm,\n  forgotPassword: catchAsyncError(forgotPassword),\n  sendResetEmail,\n  resetPasswordForm,\n  validatePassword,\n  resetPassword: catchAsyncError(resetPassword),\n  validResetToken: catchAsyncError(validResetToken),\n  sendPasswordUpdatedEmail: catchAsyncError(sendPasswordUpdatedEmail),\n  validateHuman,\n};\n","import express from 'express';\nimport { ensureLoggedIn } from 'connect-ensure-login';\nimport mongoose from 'mongoose';\nimport userController from '../controllers/user.controller';\n\nexport const userRouter = express.Router();\nconst User = mongoose.model('User');\n\nuserRouter.param('id', async (req, res, next, id) => {\n  try {\n    if (!mongoose.Types.ObjectId.isValid(id)) {\n      throw new Error('Invalid user id');\n    }\n    const user = await User.findById(id);\n    if (!user) {\n      throw new Error('No user found');\n    } else {\n      req.docFromId = user;\n      next();\n    }\n  } catch (err) {\n    next(err.message);\n  }\n});\n\nuserRouter.route('/signup')\n  .get(userController.signupForm)\n  .post(\n    userController.validateNewUser,\n    userController.validateHuman('signup'),\n    userController.createOne,\n    userController.sendConfirmEmail,\n  );\n\nuserRouter.route('/user/:id')\n  .get(ensureLoggedIn(), userController.getOne)\n  .put(userController.updateOne)\n  .delete(userController.deleteOne);\n\nuserRouter.route('/resend')\n  .get(userController.requestResend)\n  .post(userController.validateEmail, userController.validateHuman('confirmEmail'), userController.resend, userController.sendConfirmEmail);\nuserRouter.get('/confirm/:token', userController.confirmEmail);\n\nuserRouter.route('/forgot')\n  .get(userController.forgotPasswordForm)\n  .post(userController.validateEmail, userController.validateHuman('forgotPassword'), userController.forgotPassword, userController.sendResetEmail);\n\nuserRouter.route('/reset/:token')\n  .get(userController.validResetToken, userController.resetPasswordForm)\n  .post(\n    userController.validResetToken,\n    userController.validatePassword,\n    userController.resetPassword,\n    userController.sendPasswordUpdatedEmail,\n  );\n","import passport from 'passport';\nimport mongoose from 'mongoose';\n\nimport { userValidatorSchema, validateUserForm } from './userValidator';\n\nconst User = mongoose.model('User');\n\nconst loginForm = (req, res) => res.render('login');\n\n// logs in a user\nconst loginUser = passport.authenticate('local', {\n  successReturnToOrRedirect: '/',\n  failureRedirect: '/login',\n  failureFlash: true,\n  successFlash: 'You have logged in',\n});\n\nconst logoutUser = (req, res) => {\n  req.logout();\n  req.flash('info', 'You have logged out');\n  res.redirect('/');\n};\n\n// checks credentials but does not log them in\nconst authLocal = passport.authorize('local', {\n  failureRedirect: '/link/local',\n  failureFlash: 'Email or password is invalid',\n});\n\nconst linkLocalForm = (req, res) => res.render('link_local');\n\nconst genOauthLogin = (provider, config = {}) => ({\n  auth(req, res, next) {\n    const fn = req.user ? passport.authorize : passport.authenticate;\n    return fn.call(passport, provider, config.scope && { scope: config.scope })(req, res, next);\n  },\n  authCb(req, res, next) {\n    const fn = req.user ? passport.authorize : passport.authenticate;\n    const routes = req.user ?\n      {\n        failureRedirect: '/profile',\n        failureFlash: `${provider} account was not linked`,\n      } :\n      (err, user, info) => {\n        if (err) { return next(err); }\n        if (!user) {\n          req.flash('error', `Permission to login via ${provider} was denied`);\n          return res.redirect('/login');\n        }\n\n        return req.login(user, (error) => {\n          if (error) { return next(error); }\n          req.flash('success', `You have logged in, ${user[provider].displayName || user[provider].username}`);\n          if (info.firstLogin) { return res.redirect('/profile'); }\n          return res.redirect('/');\n        });\n      };\n    return fn.call(passport, provider, routes)(req, res, next);\n  },\n});\n\nconst linkAccount = async (req, res, next) => {\n  const { user, account } = req;\n\n  // user who has already logged in has authorised another account so we need to link them\n  if (user && account) {\n    const accountObj = account.toObject({\n      transform(doc, ret) {\n        const newRet = Object.assign({}, ret);\n        delete newRet.__v;\n        delete newRet._id;\n        return newRet;\n      },\n    });\n    if (accountObj.local) {\n      /* if req.user is a social account and they try to link to local, then we must delete the\n          local account otherwise there will be a duplicate in the db when we try to add the local\n          info to the social account. Since the user model doesn't allow duplicate emails, it will\n          throw an error if we didn't do this */\n      await User.deleteOne({ 'local.email': accountObj.local.email });\n    }\n    // merge accounts but preserve original username\n    Object.assign(user, accountObj, { username: user.username });\n    await user.save();\n    await account.remove();\n    req.flash('success', 'Accounts have been linked');\n    return res.redirect('/profile');\n  }\n  return next();\n};\n\nconst unlinkAccount = async (req, res, next) => {\n  const type = req.params.account;\n  const types = ['twitter', 'google', 'facebook', 'local'];\n  const { user } = req;\n  if (!types.includes(type)) {\n    const err = new Error('Unknown account type');\n    err.status = 400;\n    return next(err);\n  }\n\n  if (user.accountsTotal === 1) {\n    req.flash('error', 'Unable to unlink solo account');\n    return res.redirect('/profile');\n  }\n\n  if (type === 'local') {\n    const local = Object.assign({}, user.local);\n    user.local = undefined;\n    await user.save();\n    await User.create({ local, username: await User.genUniqueUsername() });\n  } else {\n    user[type].token = undefined;\n    await user.save();\n  }\n  req.flash('success', 'Account has been unlinked');\n  return res.redirect('/profile');\n};\n\nconst profile = (req, res) => {\n  const { user } = req;\n\n  const linkedAccounts = Object.entries(user.toObject()).reduce((all, [type, acc]) => {\n    if ((type === 'local' && acc.email) || acc.token) {\n      all[type] = acc.email || acc.displayName;\n    }\n    return all;\n  }, {});\n\n  const linkable = ['local', 'twitter', 'google', 'facebook']\n    .filter(type => !linkedAccounts[type]);\n\n  res.render('profile', {\n    body: { username: req.user.username, email: req.user.local.email },\n    linkedAccounts,\n    linkable,\n  });\n};\n\nconst preValidateProfile = (req, res, next) => {\n  if (req.body.password) {\n    return next('route');\n  }\n  return next();\n};\n\nconst validateEmail = validateUserForm(userValidatorSchema('email'), null, true);\nconst validateUsername = validateUserForm(userValidatorSchema('username'), null, true);\nconst validatePassword = validateUserForm(userValidatorSchema('password', 'password-confirm'), null, true);\n\nconst updateProfile = async (req, res) => {\n  const { username, email, password } = req.body;\n  if (username !== req.user.username) {\n    req.user.username = username;\n  }\n\n  if (req.user.local && email !== req.user.local.email) {\n    req.user.local.email = email;\n  }\n\n  if (password) {\n    req.user.local.password = await User.hashPassword(password);\n  }\n\n  await req.user.save();\n  req.flash('success', 'Account updated');\n  res.redirect('/profile');\n};\n\nexport default {\n  loginForm,\n  loginUser,\n  logoutUser,\n  genOauthLogin,\n  profile,\n  authLocal,\n  linkAccount,\n  unlinkAccount,\n  linkLocalForm,\n  updateProfile,\n  preValidateProfile,\n  validateEmail,\n  validatePassword,\n  validateUsername,\n};\n","import express from 'express';\n\nimport authController from '../controllers/auth.controller';\nimport { catchAsyncError } from '../utils/helpers';\n\nconst isLoggedIn = (req, res, next) => {\n  if (req.isAuthenticated()) {\n    next();\n  } else {\n    res.redirect('/');\n  }\n};\n\nexport const authRouter = express.Router();\n\nauthRouter.get('/login', authController.loginForm);\nauthRouter.post('/login', authController.loginUser);\nauthRouter.get('/logout', isLoggedIn, authController.logoutUser);\nauthRouter.get('/profile', isLoggedIn, authController.profile);\nauthRouter.post('/profile', [\n  isLoggedIn,\n  authController.validateUsername,\n  authController.validateEmail,\n  authController.validatePassword,\n  catchAsyncError(authController.updateProfile),\n]);\n\nauthRouter.get('/link/local', isLoggedIn, authController.linkLocalForm);\nauthRouter.post('/link/local', isLoggedIn, authController.authLocal, catchAsyncError(authController.linkAccount));\nauthRouter.post('/unlink/:account', isLoggedIn, catchAsyncError(authController.unlinkAccount));\n\n[\n  {\n    provider: 'facebook',\n    config: {\n      scope: 'email',\n    },\n  },\n  { provider: 'twitter' },\n  {\n    provider: 'google',\n    config: {\n      scope: 'https://www.googleapis.com/auth/userinfo.profile',\n    },\n  },\n].forEach(({ provider, config }) => {\n  const { auth, authCb } = authController.genOauthLogin(provider, config);\n  authRouter.get(`/auth/${provider}`, auth);\n  authRouter.get(`/auth/${provider}/callback`, authCb, catchAsyncError(authController.linkAccount));\n  authRouter.get(`/link/${provider}`, isLoggedIn, auth);\n});\n","import express from 'express';\nimport { userRouter } from './user.router';\nimport { authRouter } from './auth.router';\n\nconst routes = express.Router();\n\nroutes.use('/', authRouter);\nroutes.use('/', userRouter);\n\nroutes.get('/', (req, res) => {\n  res.render('index', { title: 'Join' });\n});\n\nroutes.post('/chat', (req, res) => {\n  res.render('chat', { title: 'Chat', room: req.body.room });\n});\n\n// handle mongoose validation errors\nroutes.use((err, req, res, next) => {\n  if (!err.errors) {\n    return next(err);\n  }\n\n  const validationErrors = Object.keys(err.errors);\n\n  if (validationErrors.length > 0) {\n    validationErrors.forEach(e => req.flash('error', err.errors[e].message));\n  }\n  return res.redirect('back');\n});\n\nroutes.use((err, req, res, next) => { // eslint-disable-line no-unused-vars\n  const status = err.status || 500;\n\n  res.status(status).render('error', {\n    status,\n    message: process.env.NODE_ENV === 'development' ? err : err.message,\n  });\n});\n\nexport default routes;\n","/* eslint-disable no-console */\n\nimport express from 'express';\nimport http from 'http';\nimport socketIO from 'socket.io';\nimport { promisify } from 'es6-promisify';\n\nimport connect from './db';\nimport './passport';\nimport './mailer';\nimport genSocketEvents from './socketEvent';\nimport { default as globalMiddleware, session } from './middleware';\nimport routes from './routes';\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIO(server);\nconnect().catch(err => console.error('Could not connect to DB', err.message));\n\napp.set('view engine', 'pug');\n\n/* without this, express incorrectly gets wrong header info because it thinks requests are coming\n   from nginx so for eg. req.protocol would be 'http' when it should be 'https' */\napp.set('trust proxy', true);\n\napp.use(globalMiddleware);\n\nio.use((socket, next) => {\n  session(socket.handshake, {}, next);\n});\n\nio.on('connection', (socket) => {\n  console.log('New user connected');\n  genSocketEvents(socket, io);\n});\n\n// convert callback based methods to use promises\napp.use((req, res, next) => {\n  req.login = promisify(req.login.bind(req));\n  next();\n});\n\n// pass variables to all templates\napp.use((req, res, next) => {\n  const flashes = req.flash();\n  res.locals.user = req.user;\n  res.locals.flashes = Object.keys(flashes).length > 0 ? flashes : undefined;\n  next();\n});\napp.use('/', routes);\n\nexport { server as default, io };\n","/* eslint-disable no-console */\n\nimport server, { io } from './server';\n\nconst port = process.env.PORT || 4000;\nlet cServer = server;\nlet cIo = io;\n\nif (module.hot) {\n  module.hot.accept('./server', () => {\n    console.log('Re-attaching event listeners to updated server module');\n    cServer.close();\n    server.listen(port);\n    cServer = server;\n\n    cIo.close();\n    io.attach(cServer);\n    cIo = io;\n  });\n}\n\nserver.listen(port, () => {\n  console.log(`Server started on port ${port}`);\n});\n","module.exports = require(\"connect-mongo\");"],"sourceRoot":""}